"""
WhatsApp Payroll Bot - Multi-Tenant Conversational Interface
950+ lines of advanced chatbot functionality
"""

import asyncio
import logging
import json
import re
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, date, timedelta
from dataclasses import dataclass
from enum import Enum
import uuid

import httpx
from twilio.rest import Client as TwilioClient
from twilio.base.exceptions import TwilioException

from ..config.settings import get_settings
from ..models.base import UserRole, MessageChannel, MessagePriority
from ..services.payroll_engine import PayrollEngine
from ..services.sociallink_engine import SocialLinkEngine

settings = get_settings()
logger = logging.getLogger(__name__)


class ConversationState(Enum):
    """Bot conversation states"""
    IDLE = "idle"
    AUTHENTICATING = "authenticating"
    MENU = "menu"
    CHECKING_IN = "checking_in"
    CHECKING_OUT = "checking_out"
    REQUESTING_PAYSLIP = "requesting_payslip"
    REQUESTING_OVERTIME = "requesting_overtime"
    REQUESTING_VACATION = "requesting_vacation"
    TEAM_MANAGEMENT = "team_management"
    PAYROLL_MANAGEMENT = "payroll_management"
    EMPLOYEE_LOOKUP = "employee_lookup"
    GEOLOCATION_REQUIRED = "geolocation_required"


@dataclass
class BotMessage:
    """Bot message structure"""
    text: str
    buttons: Optional[List[Dict[str, str]]] = None
    media_url: Optional[str] = None
    requires_location: bool = False
    quick_replies: Optional[List[str]] = None


@dataclass
class UserSession:
    """User conversation session"""
    user_id: str
    company_id: str
    phone_number: str
    state: ConversationState
    context: Dict[str, Any]
    last_activity: datetime
    authenticated: bool = False
    role: Optional[UserRole] = None
    employee_data: Optional[Dict[str, Any]] = None


class GeolocationValidator:
    """Validate user location for check-in/out"""
    
    @staticmethod
    def calculate_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
        """Calculate distance between two coordinates in meters"""
        from math import radians, cos, sin, asin, sqrt
        
        # Convert to radians
        lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
        
        # Haversine formula
        dlat = lat2 - lat1
        dlon = lon2 - lon1
        a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
        c = 2 * asin(sqrt(a))
        
        # Earth radius in meters
        r = 6371000
        return c * r
    
    @classmethod
    def is_within_office_radius(cls, user_lat: float, user_lon: float,
                              office_locations: List[Dict[str, float]],
                              radius_meters: int = 100) -> bool:
        """Check if user is within office radius"""
        for office in office_locations:
            office_lat = office.get("latitude")
            office_lon = office.get("longitude")
            
            if office_lat and office_lon:
                distance = cls.calculate_distance(user_lat, user_lon, office_lat, office_lon)
                if distance <= radius_meters:
                    return True
        
        return False


class MessageTemplates:
    """WhatsApp message templates"""
    
    @staticmethod
    def welcome_message(employee_name: str) -> BotMessage:
        return BotMessage(
            text=f"¬°Hola {employee_name}! üëã\n\n"
                 f"Bienvenido a huntRED¬Æ - tu asistente de n√≥mina inteligente.\n\n"
                 f"¬øEn qu√© puedo ayudarte hoy?",
            buttons=[
                {"id": "entrada", "title": "‚è∞ Entrada/Salida"},
                {"id": "recibo", "title": "üí∞ Mi Recibo"},
                {"id": "menu", "title": "üìã Men√∫ Completo"}
            ]
        )
    
    @staticmethod
    def main_menu(role: UserRole) -> BotMessage:
        """Generate main menu based on user role"""
        base_options = [
            "‚è∞ *entrada* - Registrar entrada/salida",
            "üí∞ *recibo* - Ver mi √∫ltimo recibo",
            "üí≥ *saldo* - Consultar mi saldo",
            "üèñÔ∏è *vacaciones* - D√≠as de vacaciones",
            "üìÖ *horario* - Mi horario de trabajo"
        ]
        
        if role in [UserRole.SUPERVISOR, UserRole.HR_ADMIN, UserRole.SUPER_ADMIN]:
            base_options.extend([
                "üë• *equipo* - Gestionar mi equipo",
                "‚úÖ *aprobar* - Aprobar solicitudes",
                "üìä *reporte_asistencia* - Reporte de asistencia"
            ])
        
        if role in [UserRole.HR_ADMIN, UserRole.SUPER_ADMIN]:
            base_options.extend([
                "üë®‚Äçüíº *empleados* - Gestionar empleados",
                "üí∞ *estado_nomina* - Estado de n√≥mina",
                "üìà *resumen* - Resumen ejecutivo",
                "üìã *reportes* - Reportes avanzados"
            ])
        
        menu_text = "üìã *MEN√ö PRINCIPAL*\n\n" + "\n".join(base_options)
        menu_text += "\n\nüí¨ Escribe el comando que necesites o usa los botones."
        
        return BotMessage(text=menu_text)
    
    @staticmethod
    def check_in_success(location: str = None) -> BotMessage:
        timestamp = datetime.now().strftime("%H:%M")
        location_text = f" desde {location}" if location else ""
        
        return BotMessage(
            text=f"‚úÖ *Entrada registrada*\n\n"
                 f"üïê Hora: {timestamp}\n"
                 f"üìç Ubicaci√≥n: {location_text}\n\n"
                 f"¬°Que tengas un excelente d√≠a de trabajo! üí™"
        )
    
    @staticmethod
    def check_out_success(hours_worked: float) -> BotMessage:
        timestamp = datetime.now().strftime("%H:%M")
        
        return BotMessage(
            text=f"‚úÖ *Salida registrada*\n\n"
                 f"üïê Hora: {timestamp}\n"
                 f"‚è±Ô∏è Horas trabajadas: {hours_worked:.1f}h\n\n"
                 f"¬°Descansa bien! üòä"
        )
    
    @staticmethod
    def payslip_summary(payslip_data: Dict[str, Any]) -> BotMessage:
        income = payslip_data["income"]
        deductions = payslip_data["deductions"]
        net_pay = payslip_data["net_pay"]
        period = payslip_data["pay_period"]
        
        text = f"üí∞ *RECIBO DE N√ìMINA*\n\n"
        text += f"üìÖ Per√≠odo: {period['start']} al {period['end']}\n\n"
        text += f"üíµ *INGRESOS*\n"
        text += f"‚Ä¢ Salario base: ${income['base_salary']:,.2f}\n"
        
        if income['overtime_amount'] > 0:
            text += f"‚Ä¢ Horas extra: ${income['overtime_amount']:,.2f}\n"
        if income['bonuses'] > 0:
            text += f"‚Ä¢ Bonos: ${income['bonuses']:,.2f}\n"
        
        text += f"‚Ä¢ *Total bruto: ${income['gross_total']:,.2f}*\n\n"
        text += f"‚ûñ *DEDUCCIONES*\n"
        text += f"‚Ä¢ IMSS: ${deductions['imss']:,.2f}\n"
        text += f"‚Ä¢ ISR: ${deductions['isr']:,.2f}\n"
        
        if deductions['loans'] > 0:
            text += f"‚Ä¢ Pr√©stamos: ${deductions['loans']:,.2f}\n"
        
        text += f"‚Ä¢ *Total deducciones: ${deductions['total']:,.2f}*\n\n"
        text += f"üí∞ *NETO A PAGAR: ${net_pay:,.2f}*"
        
        return BotMessage(
            text=text,
            buttons=[
                {"id": "payslip_pdf", "title": "üìÑ PDF Detallado"},
                {"id": "payslip_history", "title": "üìà Historial"},
                {"id": "menu", "title": "üîô Men√∫"}
            ]
        )
    
    @staticmethod
    def vacation_balance(remaining_days: int, used_days: int, total_days: int) -> BotMessage:
        return BotMessage(
            text=f"üèñÔ∏è *BALANCE DE VACACIONES*\n\n"
                 f"üìä D√≠as disponibles: *{remaining_days}*\n"
                 f"üìÖ D√≠as utilizados: {used_days}\n"
                 f"üìã Total anual: {total_days}\n\n"
                 f"¬øDeseas solicitar d√≠as de vacaciones?",
            buttons=[
                {"id": "request_vacation", "title": "üìù Solicitar Vacaciones"},
                {"id": "vacation_history", "title": "üìú Historial"},
                {"id": "menu", "title": "üîô Men√∫"}
            ]
        )
    
    @staticmethod
    def team_overview(team_data: List[Dict[str, Any]]) -> BotMessage:
        text = f"üë• *RESUMEN DEL EQUIPO*\n\n"
        text += f"üìä Total empleados: {len(team_data)}\n\n"
        
        # Present team status
        present_count = sum(1 for emp in team_data if emp.get("status") == "present")
        absent_count = len(team_data) - present_count
        
        text += f"‚úÖ Presentes: {present_count}\n"
        text += f"‚ùå Ausentes: {absent_count}\n\n"
        
        # Today's activity
        text += "*Actividad de hoy:*\n"
        for emp in team_data[:5]:  # Show first 5
            status_icon = "‚úÖ" if emp.get("status") == "present" else "‚ùå"
            text += f"{status_icon} {emp['name']}\n"
        
        if len(team_data) > 5:
            text += f"... y {len(team_data) - 5} m√°s"
        
        return BotMessage(
            text=text,
            buttons=[
                {"id": "team_attendance", "title": "üìä Asistencia Detallada"},
                {"id": "team_approvals", "title": "‚úÖ Aprobaciones"},
                {"id": "menu", "title": "üîô Men√∫"}
            ]
        )
    
    @staticmethod
    def error_message(error_type: str) -> BotMessage:
        messages = {
            "location_required": "üìç Necesito tu ubicaci√≥n para registrar la entrada/salida.\n\n"
                               "Por favor, comparte tu ubicaci√≥n actual.",
            "outside_office": "‚ùå No est√°s dentro del √°rea de trabajo permitida.\n\n"
                            "Debes estar cerca de la oficina para registrar entrada/salida.",
            "already_checked_in": "‚ö†Ô∏è Ya tienes una entrada registrada hoy.\n\n"
                                "¬øDeseas registrar tu salida?",
            "not_checked_in": "‚ö†Ô∏è No tienes una entrada registrada hoy.\n\n"
                            "Primero debes registrar tu entrada.",
            "authentication_failed": "‚ùå No pude verificar tu identidad.\n\n"
                                   "Por favor, contacta a Recursos Humanos.",
            "invalid_command": "‚ùì No entend√≠ tu solicitud.\n\n"
                             "Escribe *menu* para ver las opciones disponibles.",
            "system_error": "üîß Hay un problema t√©cnico temporal.\n\n"
                          "Por favor, intenta de nuevo en unos minutos."
        }
        
        return BotMessage(text=messages.get(error_type, messages["system_error"]))


class WhatsAppBotEngine:
    """Main WhatsApp Bot Engine - Multi-tenant Architecture"""
    
    def __init__(self):
        self.sessions: Dict[str, UserSession] = {}
        self.payroll_engine = PayrollEngine()
        self.social_engine = SocialLinkEngine()
        self.geolocation_validator = GeolocationValidator()
        
        # Initialize Twilio client
        self.twilio_client = TwilioClient(
            settings.TWILIO_ACCOUNT_SID,
            settings.TWILIO_AUTH_TOKEN
        )
    
    async def process_webhook(self, webhook_data: Dict[str, Any], company_id: str) -> Dict[str, Any]:
        """Process incoming WhatsApp webhook for specific company"""
        try:
            # Extract message data
            from_number = webhook_data.get("From", "").replace("whatsapp:", "")
            to_number = webhook_data.get("To", "").replace("whatsapp:", "")
            message_body = webhook_data.get("Body", "").strip()
            
            # Handle location sharing
            latitude = webhook_data.get("Latitude")
            longitude = webhook_data.get("Longitude")
            location_data = None
            if latitude and longitude:
                location_data = {"latitude": float(latitude), "longitude": float(longitude)}
            
            logger.info(f"Processing message from {from_number} for company {company_id}")
            
            # Get or create user session
            session = await self._get_or_create_session(from_number, company_id)
            
            # Authenticate user if not already authenticated
            if not session.authenticated:
                auth_result = await self._authenticate_user(session, from_number, company_id)
                if not auth_result:
                    response = MessageTemplates.error_message("authentication_failed")
                    await self._send_message(from_number, response, company_id)
                    return {"status": "error", "message": "Authentication failed"}
            
            # Process the message
            response = await self._process_user_message(session, message_body, location_data)
            
            # Send response
            await self._send_message(from_number, response, company_id)
            
            # Update session
            session.last_activity = datetime.now()
            self.sessions[from_number] = session
            
            return {"status": "success", "message": "Message processed"}
            
        except Exception as e:
            logger.error(f"Error processing webhook: {e}")
            error_response = MessageTemplates.error_message("system_error")
            if 'from_number' in locals():
                await self._send_message(from_number, error_response, company_id)
            return {"status": "error", "message": str(e)}
    
    async def _get_or_create_session(self, phone_number: str, company_id: str) -> UserSession:
        """Get existing session or create new one"""
        if phone_number in self.sessions:
            session = self.sessions[phone_number]
            # Check if session is still valid (24 hours)
            if datetime.now() - session.last_activity < timedelta(hours=24):
                return session
        
        # Create new session
        session = UserSession(
            user_id=str(uuid.uuid4()),
            company_id=company_id,
            phone_number=phone_number,
            state=ConversationState.IDLE,
            context={},
            last_activity=datetime.now(),
            authenticated=False
        )
        
        return session
    
    async def _authenticate_user(self, session: UserSession, phone_number: str, 
                               company_id: str) -> bool:
        """Authenticate user by phone number"""
        try:
            # Mock database lookup - replace with actual database call
            employee_data = await self._lookup_employee_by_phone(phone_number, company_id)
            
            if employee_data:
                session.authenticated = True
                session.role = UserRole(employee_data.get("role", "employee"))
                session.employee_data = employee_data
                logger.info(f"User {phone_number} authenticated successfully")
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Authentication error: {e}")
            return False
    
    async def _lookup_employee_by_phone(self, phone_number: str, company_id: str) -> Optional[Dict[str, Any]]:
        """Lookup employee by phone number - Mock implementation"""
        # This would be replaced with actual database queries
        mock_employees = {
            "+525512345678": {
                "id": "emp_001",
                "name": "Juan P√©rez",
                "role": "employee",
                "monthly_salary": 15000.0,
                "department": "Desarrollo",
                "manager_id": "emp_002"
            },
            "+525587654321": {
                "id": "emp_002", 
                "name": "Mar√≠a Gonz√°lez",
                "role": "supervisor",
                "monthly_salary": 25000.0,
                "department": "Desarrollo"
            }
        }
        
        return mock_employees.get(phone_number)
    
    async def _process_user_message(self, session: UserSession, message: str, 
                                  location_data: Optional[Dict[str, float]]) -> BotMessage:
        """Process user message based on current state and role"""
        message_lower = message.lower().strip()
        
        # Handle location-based states first
        if session.state == ConversationState.GEOLOCATION_REQUIRED:
            if location_data:
                return await self._handle_location_check(session, location_data)
            else:
                return MessageTemplates.error_message("location_required")
        
        # Handle common commands
        if message_lower in ["menu", "men√∫", "inicio", "start"]:
            session.state = ConversationState.MENU
            return MessageTemplates.main_menu(session.role)
        
        elif message_lower in ["hola", "hello", "hi"]:
            return MessageTemplates.welcome_message(session.employee_data["name"])
        
        # Role-based command processing
        elif message_lower in ["entrada", "salida", "check", "checkin", "checkout"]:
            return await self._handle_attendance_command(session, message_lower)
        
        elif message_lower in ["recibo", "nomina", "payslip", "sueldo"]:
            return await self._handle_payslip_request(session)
        
        elif message_lower in ["saldo", "balance", "dinero"]:
            return await self._handle_balance_request(session)
        
        elif message_lower in ["vacaciones", "vacation", "holidays"]:
            return await self._handle_vacation_request(session)
        
        elif message_lower in ["horario", "schedule", "tiempo"]:
            return await self._handle_schedule_request(session)
        
        # Supervisor/Manager commands
        elif message_lower in ["equipo", "team"] and session.role.value in ["supervisor", "hr_admin", "super_admin"]:
            return await self._handle_team_command(session)
        
        elif message_lower in ["aprobar", "approve"] and session.role.value in ["supervisor", "hr_admin", "super_admin"]:
            return await self._handle_approvals_command(session)
        
        elif message_lower == "reporte_asistencia" and session.role.value in ["supervisor", "hr_admin", "super_admin"]:
            return await self._handle_attendance_report(session)
        
        # HR Admin commands
        elif message_lower == "empleados" and session.role.value in ["hr_admin", "super_admin"]:
            return await self._handle_employee_management(session)
        
        elif message_lower == "estado_nomina" and session.role.value in ["hr_admin", "super_admin"]:
            return await self._handle_payroll_status(session)
        
        elif message_lower == "resumen" and session.role.value in ["hr_admin", "super_admin"]:
            return await self._handle_executive_summary(session)
        
        elif message_lower == "reportes" and session.role.value in ["hr_admin", "super_admin"]:
            return await self._handle_advanced_reports(session)
        
        # Button responses
        elif message_lower.startswith("payslip_"):
            return await self._handle_payslip_action(session, message_lower)
        
        else:
            return MessageTemplates.error_message("invalid_command")
    
    async def _handle_attendance_command(self, session: UserSession, command: str) -> BotMessage:
        """Handle check-in/check-out commands"""
        session.state = ConversationState.GEOLOCATION_REQUIRED
        session.context["attendance_action"] = "check_in" if command in ["entrada", "checkin"] else "check_out"
        
        return BotMessage(
            text="üìç Para registrar tu entrada/salida, necesito tu ubicaci√≥n.\n\n"
                 "Por favor, comparte tu ubicaci√≥n actual.",
            requires_location=True
        )
    
    async def _handle_location_check(self, session: UserSession, location_data: Dict[str, float]) -> BotMessage:
        """Handle location validation for check-in/out"""
        user_lat = location_data["latitude"]
        user_lon = location_data["longitude"]
        
        # Mock office locations - would come from company settings
        office_locations = [
            {"latitude": 19.4326, "longitude": -99.1332}  # Mexico City example
        ]
        
        if not self.geolocation_validator.is_within_office_radius(user_lat, user_lon, office_locations):
            session.state = ConversationState.IDLE
            return MessageTemplates.error_message("outside_office")
        
        # Process attendance
        action = session.context.get("attendance_action", "check_in")
        
        if action == "check_in":
            # Record check-in
            session.state = ConversationState.IDLE
            return MessageTemplates.check_in_success("Oficina Principal")
        else:
            # Record check-out and calculate hours
            hours_worked = 8.5  # Mock calculation
            session.state = ConversationState.IDLE
            return MessageTemplates.check_out_success(hours_worked)
    
    async def _handle_payslip_request(self, session: UserSession) -> BotMessage:
        """Handle payslip request"""
        # Generate mock payslip using payroll engine
        employee_data = session.employee_data
        
        try:
            payroll_calc = self.payroll_engine.calculate_payroll(
                employee_data,
                date.today().replace(day=1),  # Start of month
                date.today(),  # End of month
                overtime_hours=10  # Mock overtime
            )
            
            payslip_data = self.payroll_engine.generate_payslip_data(payroll_calc)
            return MessageTemplates.payslip_summary(payslip_data)
            
        except Exception as e:
            logger.error(f"Error generating payslip: {e}")
            return MessageTemplates.error_message("system_error")
    
    async def _handle_balance_request(self, session: UserSession) -> BotMessage:
        """Handle balance/salary request"""
        employee_data = session.employee_data
        monthly_salary = employee_data.get("monthly_salary", 0)
        
        # Calculate next payday
        today = date.today()
        if today.day <= 15:
            next_payday = today.replace(day=15)
        else:
            next_month = today.replace(day=28) + timedelta(days=4)
            next_payday = next_month.replace(day=1)
        
        days_until_payday = (next_payday - today).days
        
        return BotMessage(
            text=f"üí∞ *INFORMACI√ìN SALARIAL*\n\n"
                 f"üíµ Salario mensual: ${monthly_salary:,.2f}\n"
                 f"üìÖ Pr√≥ximo pago: {next_payday.strftime('%d/%m/%Y')}\n"
                 f"‚è≥ D√≠as restantes: {days_until_payday}\n\n"
                 f"üí° ¬øNecesitas un adelanto de n√≥mina?",
            buttons=[
                {"id": "request_advance", "title": "üí∏ Solicitar Adelanto"},
                {"id": "payslip", "title": "üßæ Ver Recibo"},
                {"id": "menu", "title": "üîô Men√∫"}
            ]
        )
    
    async def _handle_vacation_request(self, session: UserSession) -> BotMessage:
        """Handle vacation balance request"""
        # Mock vacation data - would come from database
        vacation_data = {
            "total_days": 12,
            "used_days": 3,
            "remaining_days": 9
        }
        
        return MessageTemplates.vacation_balance(
            vacation_data["remaining_days"],
            vacation_data["used_days"],
            vacation_data["total_days"]
        )
    
    async def _handle_schedule_request(self, session: UserSession) -> BotMessage:
        """Handle work schedule request"""
        # Mock schedule data
        return BotMessage(
            text="üìÖ *MI HORARIO DE TRABAJO*\n\n"
                 "üïò Lunes a Viernes: 9:00 AM - 6:00 PM\n"
                 "üïõ Almuerzo: 1:00 PM - 2:00 PM\n"
                 "üìç Modalidad: H√≠brida\n\n"
                 "üìä Esta semana:\n"
                 "‚Ä¢ Horas trabajadas: 32/40\n"
                 "‚Ä¢ D√≠as restantes: 2",
            buttons=[
                {"id": "time_tracking", "title": "‚è±Ô∏è Seguimiento"},
                {"id": "schedule_change", "title": "üìù Cambio Horario"},
                {"id": "menu", "title": "üîô Men√∫"}
            ]
        )
    
    async def _handle_team_command(self, session: UserSession) -> BotMessage:
        """Handle team management command"""
        # Mock team data
        team_data = [
            {"name": "Ana L√≥pez", "status": "present"},
            {"name": "Carlos Ruiz", "status": "absent"},
            {"name": "Diana Torres", "status": "present"},
        ]
        
        return MessageTemplates.team_overview(team_data)
    
    async def _handle_approvals_command(self, session: UserSession) -> BotMessage:
        """Handle pending approvals"""
        return BotMessage(
            text="‚úÖ *APROBACIONES PENDIENTES*\n\n"
                 "üìã Tienes 3 solicitudes por revisar:\n\n"
                 "1. üèñÔ∏è Ana L√≥pez - Vacaciones (2 d√≠as)\n"
                 "2. ‚è∞ Carlos Ruiz - Horas extra (5h)\n"
                 "3. üè† Diana Torres - Home Office\n\n"
                 "¬øQu√© solicitud deseas revisar?",
            buttons=[
                {"id": "approve_vacation", "title": "üèñÔ∏è Vacaciones"},
                {"id": "approve_overtime", "title": "‚è∞ Horas Extra"},
                {"id": "approve_remote", "title": "üè† Home Office"}
            ]
        )
    
    async def _handle_attendance_report(self, session: UserSession) -> BotMessage:
        """Handle attendance report request"""
        return BotMessage(
            text="üìä *REPORTE DE ASISTENCIA*\n\n"
                 "üìÖ Semana actual:\n"
                 "‚Ä¢ Asistencia promedio: 92%\n"
                 "‚Ä¢ Llegadas tard√≠as: 2\n"
                 "‚Ä¢ Ausencias: 1\n\n"
                 "üë• Por empleado:\n"
                 "‚úÖ Ana L√≥pez: 100%\n"
                 "‚ö†Ô∏è Carlos Ruiz: 80% (1 falta)\n"
                 "‚úÖ Diana Torres: 95%",
            buttons=[
                {"id": "detailed_report", "title": "üìã Reporte Detallado"},
                {"id": "export_report", "title": "üìä Exportar Excel"},
                {"id": "menu", "title": "üîô Men√∫"}
            ]
        )
    
    async def _handle_employee_management(self, session: UserSession) -> BotMessage:
        """Handle employee management"""
        return BotMessage(
            text="üë®‚Äçüíº *GESTI√ìN DE EMPLEADOS*\n\n"
                 "üìä Total empleados: 25\n"
                 "üÜï Nuevos este mes: 2\n"
                 "üì§ Bajas: 0\n\n"
                 "¬øQu√© deseas hacer?",
            buttons=[
                {"id": "add_employee", "title": "‚ûï Agregar Empleado"},
                {"id": "employee_list", "title": "üìã Lista Empleados"},
                {"id": "employee_reports", "title": "üìä Reportes"},
                {"id": "menu", "title": "üîô Men√∫"}
            ]
        )
    
    async def _handle_payroll_status(self, session: UserSession) -> BotMessage:
        """Handle payroll status"""
        return BotMessage(
            text="üí∞ *ESTADO DE N√ìMINA*\n\n"
                 f"üìÖ Per√≠odo: {date.today().strftime('%B %Y')}\n"
                 f"üìä Estado: En proceso\n"
                 f"‚úÖ Calculada: 25/25 empleados\n"
                 f"‚è≥ Pendiente dispersi√≥n\n\n"
                 f"üíµ Total n√≥mina: $587,450.00\n"
                 f"üìä IMSS patronal: $67,320.00",
            buttons=[
                {"id": "process_payroll", "title": "üöÄ Procesar N√≥mina"},
                {"id": "payroll_report", "title": "üìã Reporte Detallado"},
                {"id": "dispersion", "title": "üí∏ Dispersi√≥n"},
                {"id": "menu", "title": "üîô Men√∫"}
            ]
        )
    
    async def _handle_executive_summary(self, session: UserSession) -> BotMessage:
        """Handle executive summary"""
        return BotMessage(
            text="üìà *RESUMEN EJECUTIVO*\n\n"
                 "üë• *Personal:*\n"
                 "‚Ä¢ Total empleados: 25\n"
                 "‚Ä¢ Asistencia promedio: 94%\n"
                 "‚Ä¢ Rotaci√≥n: 2.1%\n\n"
                 "üí∞ *N√≥mina:*\n"
                 "‚Ä¢ Costo mensual: $587,450\n"
                 "‚Ä¢ vs. mes anterior: +3.2%\n"
                 "‚Ä¢ Horas extra: 125h\n\n"
                 "üìä *Productividad:*\n"
                 "‚Ä¢ Proyectos completados: 8\n"
                 "‚Ä¢ Satisfacci√≥n: 4.7/5",
            buttons=[
                {"id": "detailed_analytics", "title": "üìä Analytics"},
                {"id": "export_summary", "title": "üì§ Exportar"},
                {"id": "menu", "title": "üîô Men√∫"}
            ]
        )
    
    async def _handle_advanced_reports(self, session: UserSession) -> BotMessage:
        """Handle advanced reports"""
        return BotMessage(
            text="üìã *REPORTES AVANZADOS*\n\n"
                 "¬øQu√© reporte necesitas?",
            buttons=[
                {"id": "payroll_report", "title": "üí∞ Reporte N√≥mina"},
                {"id": "attendance_report", "title": "üìä Asistencia"},
                {"id": "performance_report", "title": "üéØ Desempe√±o"},
                {"id": "costs_report", "title": "üí∏ Costos"},
                {"id": "menu", "title": "üîô Men√∫"}
            ]
        )
    
    async def _handle_payslip_action(self, session: UserSession, action: str) -> BotMessage:
        """Handle payslip-related actions"""
        if action == "payslip_pdf":
            return BotMessage(
                text="üìÑ Generando tu recibo en PDF...\n\n"
                     "Te llegar√° por email en unos momentos.",
                buttons=[{"id": "menu", "title": "üîô Men√∫"}]
            )
        elif action == "payslip_history":
            return BotMessage(
                text="üìà *HISTORIAL DE RECIBOS*\n\n"
                     "üìÖ Noviembre 2024: $14,250.00\n"
                     "üìÖ Octubre 2024: $13,800.00\n"
                     "üìÖ Septiembre 2024: $14,100.00\n"
                     "üìÖ Agosto 2024: $13,950.00",
                buttons=[{"id": "menu", "title": "üîô Men√∫"}]
            )
        else:
            return MessageTemplates.error_message("invalid_command")
    
    async def _send_message(self, to_number: str, message: BotMessage, company_id: str):
        """Send WhatsApp message using Twilio"""
        try:
            # Get company WhatsApp configuration
            from_number = await self._get_company_whatsapp_number(company_id)
            
            # Send main message
            twilio_message = self.twilio_client.messages.create(
                body=message.text,
                from_=f"whatsapp:{from_number}",
                to=f"whatsapp:{to_number}"
            )
            
            # Send buttons as follow-up if any
            if message.buttons:
                button_text = "\n\n" + "\n".join([
                    f"üí¨ *{btn['title']}* - Escribe: {btn['id']}"
                    for btn in message.buttons
                ])
                
                self.twilio_client.messages.create(
                    body=button_text,
                    from_=f"whatsapp:{from_number}",
                    to=f"whatsapp:{to_number}"
                )
            
            logger.info(f"Message sent successfully to {to_number}")
            
        except TwilioException as e:
            logger.error(f"Twilio error sending message: {e}")
            raise
        except Exception as e:
            logger.error(f"Error sending message: {e}")
            raise
    
    async def _get_company_whatsapp_number(self, company_id: str) -> str:
        """Get company's dedicated WhatsApp number"""
        # Mock implementation - would query company settings
        company_numbers = {
            "company_1": "+14155238886",  # Twilio sandbox number
            "company_2": "+14155238887",
        }
        return company_numbers.get(company_id, "+14155238886")
    
    def cleanup_old_sessions(self):
        """Clean up sessions older than 24 hours"""
        cutoff = datetime.now() - timedelta(hours=24)
        expired_sessions = [
            phone for phone, session in self.sessions.items()
            if session.last_activity < cutoff
        ]
        
        for phone in expired_sessions:
            del self.sessions[phone]
        
        logger.info(f"Cleaned up {len(expired_sessions)} expired sessions")