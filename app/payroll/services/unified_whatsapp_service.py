"""
Servicio unificado de WhatsApp huntRED¬Æ para Payroll
Implementaci√≥n consolidada para sistemas de n√≥mina
"""
import logging
import json
import asyncio
from typing import Dict, Any, Optional, List, Union
from datetime import datetime, date, timedelta
from decimal import Decimal

from django.utils import timezone
from django.conf import settings
from django.core.exceptions import ValidationError

from ..models import PayrollCompany, PayrollEmployee, AttendanceRecord, EmployeeRequest, PayrollPeriod
from .. import PAYROLL_ROLES, ATTENDANCE_STATUSES, REQUEST_STATUSES
from .severance_calculation_service import SeveranceCalculationService
from .workplace_climate_service import WorkplaceClimateService

# Importamos soporte de internacionalizaci√≥n
from ..i18n import get_message, get_button_text, detect_language, SUPPORTED_LANGUAGES, DEFAULT_LANGUAGE

# Importamos la clase base del men√∫ ATS para reusabilidad
from app.ats.integrations.menu.base import BaseMenu
from app.ats.integrations.menu.whatsapp import WhatsAppMenu

logger = logging.getLogger(__name__)

class UnifiedWhatsAppService:
    """
    Servicio unificado de WhatsApp para sistema de n√≥mina.
    Consolida funcionalidades de los servicios anteriores.
    """
    
    def __init__(self, company: PayrollCompany):
        """
        Inicializa el servicio con la empresa especificada
        
        Args:
            company: Instancia de PayrollCompany a la que pertenece el servicio
        """
        self.company = company
        
        # Configuraci√≥n de WhatsApp desde la empresa
        self.webhook_token = company.whatsapp_webhook_token
        self.phone_number = company.whatsapp_phone_number
        self.business_name = company.whatsapp_business_name
        
        # Inicializar servicios auxiliares
        self.severance_service = None  # Se inicializa por empleado
        self.climate_service = WorkplaceClimateService(company)
        
        # Estado de conversaciones y preferencias de idioma
        self.user_sessions = {}
        self.user_languages = {}  # Almacena preferencias de idioma por usuario
        
        # Configuraci√≥n de la mensajer√≠a
        self.messaging_config = company.messaging_config or {
            'enable_quick_replies': True,
            'enable_buttons': True,
            'enable_list_messages': True,
            'enable_template_messages': True,
            'session_timeout_minutes': 30,
            'max_quick_replies': 3,
            'typing_delay_seconds': 1,
            'default_language': DEFAULT_LANGUAGE,
            'supported_languages': list(SUPPORTED_LANGUAGES.keys())
        }
    
    async def process_message(self, from_number: str, message: str, message_type: str = "text") -> Dict[str, Any]:
        """
        Procesa mensaje entrante de WhatsApp
        
        Args:
            from_number: N√∫mero del remitente
            message: Texto del mensaje
            message_type: Tipo de mensaje (text, location, button, list)
            
        Returns:
            Respuesta a enviar
        """
        try:
            # Normalizar n√∫mero de tel√©fono
            normalized_number = self._normalize_phone(from_number)
            
            # Detectar o recuperar idioma preferido del usuario
            user_language = self._get_user_language(normalized_number)
            
            # Si es mensaje de texto, verificar si es comando de cambio de idioma
            if message_type == "text":
                if self._check_language_change_command(normalized_number, message):
                    # Si era un comando de idioma, devolver respuesta confirmando el cambio
                    return self._create_language_changed_response(normalized_number)
            
            # Identificar empleado
            employee = self._get_employee_by_phone(normalized_number)
            if not employee:
                return await self._handle_unregistered_user(normalized_number, message)
            
            # Inicializar servicios espec√≠ficos de empleado si es necesario
            if not self.severance_service:
                self.severance_service = SeveranceCalculationService(employee)
            
            # Simulaci√≥n de "escribiendo..." para mejorar UX
            if self.messaging_config.get('enable_typing_indicators', True):
                await self._send_typing_indicator(normalized_number)
                
            # Procesar seg√∫n tipo de mensaje
            if message_type == "text":
                command = message.lower().strip()
                return await self._process_text_command(employee, normalized_number, command)
            elif message_type == "location":
                return await self._process_location(employee, normalized_number, message)
            elif message_type == "button":
                button_id = message  # En este caso, message contiene el ID del bot√≥n
                return await self._process_button_response(employee, normalized_number, button_id)
            elif message_type == "list":
                list_item_id = message  # En este caso, message contiene el ID del √≠tem
                return await self._process_list_response(employee, normalized_number, list_item_id)
            else:
                return await self._handle_unsupported_message(employee, normalized_number, message_type)
                
        except Exception as e:
            logger.error(f"Error procesando mensaje de {from_number}: {str(e)}")
            return {
                "success": False,
                "message": "‚ùå Error procesando tu mensaje. Por favor intenta de nuevo o contacta a RH.",
                "error": str(e)
            }
    
    def _normalize_phone(self, phone: str) -> str:
        """Normaliza formato de n√∫mero telef√≥nico"""
        # Eliminar formato WhatsApp
        phone = phone.replace('@c.us', '').replace('@g.us', '')
        
        # Asegurar formato internacional
        if not phone.startswith('+'):
            # Asumir M√©xico si no tiene c√≥digo pa√≠s
            if phone.startswith('52'):
                phone = f"+{phone}"
            else:
                phone = f"+52{phone}"
                
        return phone
    
    async def _send_typing_indicator(self, phone_number: str, duration_seconds: int = None) -> None:
        """
        Env√≠a indicador de "escribiendo..." a WhatsApp
        
        Args:
            phone_number: N√∫mero al que enviar indicador
            duration_seconds: Duraci√≥n en segundos, si es None usa config por defecto
        """
        if duration_seconds is None:
            duration_seconds = self.messaging_config.get('typing_delay_seconds', 1)
            
        # En implementaci√≥n real, aqu√≠ enviar√≠amos el indicador a la API
        # En esta implementaci√≥n, solo esperamos el tiempo indicado
        if duration_seconds > 0:
            await asyncio.sleep(duration_seconds)
    
    def _get_employee_by_phone(self, phone_number: str) -> Optional[PayrollEmployee]:
        """Obtiene empleado por n√∫mero de tel√©fono"""
        try:
            # Buscar por n√∫mero de tel√©fono exacto o parcial
            employee = PayrollEmployee.objects.filter(
                company=self.company
            ).filter(
                # Buscar en varios campos posibles
                phone__contains=phone_number
            ).first()
            
            if not employee:
                # Buscar por ID de plataforma
                employee = PayrollEmployee.objects.filter(
                    company=self.company,
                    platform_ids__contains=phone_number
                ).first()
            
            return employee
            
        except Exception as e:
            logger.error(f"Error buscando empleado: {str(e)}")
            return None
    
    async def _handle_unregistered_user(self, phone_number: str, message: str) -> Dict[str, Any]:
        """Maneja usuarios no registrados"""
        logger.warning(f"Usuario no registrado intentando usar el servicio: {phone_number}")
        
        # Detectar idioma del mensaje
        lang = self._detect_message_language(message)
        
        return {
            "success": False,
            "message": get_message('system', 'user_not_found', lang),
            "quick_replies": []
        }
    
    async def _handle_unsupported_message(self, employee: PayrollEmployee, 
                                         phone_number: str, message_type: str) -> Dict[str, Any]:
        """Maneja tipos de mensaje no soportados"""
        return {
            "success": True,
            "message": f"Lo siento, actualmente no puedo procesar mensajes de tipo {message_type}. Por favor, env√≠a un mensaje de texto.",
            "quick_replies": [
                {"text": "üè† Men√∫ principal", "action": "main_menu"},
                {"text": "‚ùì Ayuda", "action": "help"}
            ]
        }
    
    async def _process_text_command(self, employee: PayrollEmployee, 
                                   phone_number: str, command: str) -> Dict[str, Any]:
        """Procesa comando de texto"""
        # Obtener idioma preferido del usuario
        lang = self._get_user_language(phone_number)
        
        # Comandos de asistencia
        if command in ['entrada', 'checkin', 'llegada', 'inicio', 'check in', 'check-in', 'entr√©e', 'entrada']:
            return await self._handle_checkin(employee, phone_number)
            
        elif command in ['salida', 'checkout', 'fin', 'check out', 'check-out', 'sortie', 'sa√≠da']:
            return await self._handle_checkout(employee, phone_number)
            
        # Comandos de n√≥mina
        elif command in ['recibo', 'payslip', 'n√≥mina', 'nomina', 'pago', 'fiche', 'holerite']:
            return await self._handle_payslip_request(employee, phone_number)
        elif command in ['balance', 'saldo', 'vacaciones', 'permisos', 'solde', 'f√©rias']:
            return await self._handle_balance_inquiry(employee, phone_number)
        
        # Comandos de ayuda
        elif command in ['ayuda', 'help', 'menu', 'men√∫', 'opciones', 'comandos', 'aide', 'ajuda']:
            return await self._handle_help_command(employee, phone_number)
        
        # Comandos de idioma
        elif command in ['idioma', 'language', 'langue', 'idioma']:
            return self._handle_language_menu(phone_number)
        
        # Comandos de rol y permisos
        elif command in ['rh', 'hr', 'dashboard', 'reportes', 'informes', 'rapports', 'relat√≥rios']:
            if self._check_hr_role(employee):
                return await self._handle_hr_dashboard(employee, phone_number)
            else:
                return {
                    "success": False,
                    "message": get_message('hr', 'unauthorized', lang),
                }
        
            
        # Comando especial para cambio de rol
        elif command in ['rol', 'cambiar rol', 'switch']:
            return await self._handle_role_switch(employee, phone_number)
            
        # Comando desconocido
        else:
            return await self._handle_unknown_command(employee, phone_number, command)
    
    async def _process_location(self, employee: PayrollEmployee, 
                               phone_number: str, location_data: Union[str, Dict]) -> Dict[str, Any]:
        """
        Procesa mensaje de ubicaci√≥n
        
        Args:
            employee: Empleado que env√≠a ubicaci√≥n
            phone_number: N√∫mero del remitente
            location_data: Datos de ubicaci√≥n (JSON string o Dict)
        """
        try:
            # Parsear ubicaci√≥n si viene como string
            if isinstance(location_data, str):
                try:
                    location = json.loads(location_data)
                except json.JSONDecodeError:
                    location = {"error": "Invalid location format"}
            else:
                location = location_data
                
            # Extraer coordenadas
            latitude = location.get('latitude', 0)
            longitude = location.get('longitude', 0)
            
            if latitude == 0 or longitude == 0:
                return {
                    "success": False,
                    "message": "‚ùå No pudimos leer tu ubicaci√≥n. Por favor intenta nuevamente.",
                    "quick_replies": [
                        {"text": "üîÑ Enviar ubicaci√≥n", "action": "send_location"},
                        {"text": "üìù Entrada manual", "action": "manual_checkin"}
                    ]
                }
                
            # Verificar si hay sesi√≥n pendiente de check-in o check-out
            session = self.user_sessions.get(phone_number, {})
            pending_action = session.get('pending_action')
            
            if pending_action == 'checkin':
                # Validar ubicaci√≥n para checkin
                is_valid = self._validate_office_location(employee, 
                                                         Decimal(str(latitude)), 
                                                         Decimal(str(longitude)))
                return await self._complete_checkin(employee, phone_number, 
                                                  latitude, longitude, is_valid)
                                                  
            elif pending_action == 'checkout':
                # Validar ubicaci√≥n para checkout
                is_valid = self._validate_office_location(employee, 
                                                         Decimal(str(latitude)), 
                                                         Decimal(str(longitude)))
                return await self._complete_checkout(employee, phone_number, 
                                                   latitude, longitude, is_valid)
            else:
                # No hay acci√≥n pendiente para la ubicaci√≥n
                return {
                    "success": True,
                    "message": "üìç Recibimos tu ubicaci√≥n. ¬øQu√© deseas hacer?",
                    "quick_replies": [
                        {"text": "‚úÖ Registrar entrada", "action": "checkin"},
                        {"text": "üö™ Registrar salida", "action": "checkout"},
                        {"text": "üè† Men√∫ principal", "action": "main_menu"}
                    ]
                }
                
        except Exception as e:
            logger.error(f"Error procesando ubicaci√≥n: {str(e)}")
            return {
                "success": False,
                "message": f"‚ùå Error procesando ubicaci√≥n: {str(e)}",
                "quick_replies": [
                    {"text": "üîÑ Reintentar", "action": "retry"},
                    {"text": "üìù Entrada manual", "action": "manual_checkin"}
                ]
            }

    # M√©todos para manejo de check-in y check-out
    
    async def _handle_checkin(self, employee: PayrollEmployee, phone_number: str) -> Dict[str, Any]:
        """Maneja registro de entrada con solicitud de ubicaci√≥n"""
        # Registrar intenci√≥n de check-in en la sesi√≥n
        self.user_sessions[phone_number] = {
            'pending_action': 'checkin',
            'timestamp': datetime.now(),
            'employee_id': employee.id
        }
        
        # Si la pol√≠tica de la empresa requiere ubicaci√≥n
        if self.company.location_required_for_attendance:
            return {
                "success": True,
                "message": "üìç Por favor comparte tu ubicaci√≥n para registrar tu entrada",
                "quick_replies": [
                    {"text": "üìç Compartir ubicaci√≥n", "action": "send_location"},
                    {"text": "üìù Entrada manual", "action": "manual_checkin"},
                    {"text": "‚ùå Cancelar", "action": "cancel"}
                ]
            }
        else:
            # Si no requiere ubicaci√≥n, registrar directamente
            return await self._complete_checkin(employee, phone_number, None, None, True)
    
    async def _complete_checkin(self, employee: PayrollEmployee, phone_number: str,
                             latitude: Optional[float], longitude: Optional[float],
                             is_valid_location: bool) -> Dict[str, Any]:
        """Completa el registro de entrada"""
        try:
            # Limpiar sesi√≥n pendiente
            if phone_number in self.user_sessions:
                del self.user_sessions[phone_number]
            
            # Si la ubicaci√≥n no es v√°lida pero es requerida
            if not is_valid_location and self.company.location_required_for_attendance:
                return {
                    "success": False,
                    "message": "‚ùå No est√°s dentro del per√≠metro autorizado para registrar asistencia.",
                    "quick_replies": [
                        {"text": "üîÑ Reintentar", "action": "checkin"},
                        {"text": "üìù Solicitar excepci√≥n", "action": "exception_request"},
                        {"text": "üè† Men√∫ principal", "action": "main_menu"}
                    ]
                }
            
            # Verificar si ya hay registro de entrada hoy
            today = timezone.now().date()
            existing_record = AttendanceRecord.objects.filter(
                employee=employee,
                date=today
            ).first()
            
            if existing_record and existing_record.check_in:
                # Ya tiene registro de entrada
                formatted_time = existing_record.check_in.strftime('%H:%M')
                return {
                    "success": True,
                    "message": f"‚ÑπÔ∏è Ya registraste tu entrada hoy a las {formatted_time}.",
                    "quick_replies": [
                        {"text": "üö™ Registrar salida", "action": "checkout"},
                        {"text": "üè† Men√∫ principal", "action": "main_menu"}
                    ]
                }
            
            # Crear o actualizar registro
            if not existing_record:
                record = AttendanceRecord(
                    employee=employee,
                    company=self.company,
                    date=today,
                    status=ATTENDANCE_STATUSES.PRESENT
                )
            else:
                record = existing_record
                
            # Registrar entrada
            now = timezone.now()
            record.check_in = now
            
            # Guardar ubicaci√≥n si est√° disponible
            if latitude and longitude:
                record.check_in_location = {
                    'latitude': latitude,
                    'longitude': longitude,
                    'timestamp': now.isoformat()
                }
            
            # Guardar registro
            record.save()
            
            # Formato amigable de la hora
            formatted_time = now.strftime('%H:%M:%S')
            
            return {
                "success": True,
                "message": f"‚úÖ Entrada registrada correctamente a las {formatted_time}.",
                "quick_replies": [
                    {"text": "üìä Mi horario hoy", "action": "schedule"},
                    {"text": "üè† Men√∫ principal", "action": "main_menu"}
                ]
            }
            
        except Exception as e:
            logger.error(f"Error registrando entrada: {str(e)}")
            return {
                "success": False,
                "message": f"‚ùå Error registrando entrada: {str(e)}",
                "quick_replies": [
                    {"text": "üîÑ Reintentar", "action": "checkin"},
                    {"text": "üìû Contactar RH", "action": "contact_hr"}
                ]
            }
    
    async def _handle_checkout(self, employee: PayrollEmployee, phone_number: str) -> Dict[str, Any]:
        """Maneja registro de salida con solicitud de ubicaci√≥n"""
        # Registrar intenci√≥n de check-out en la sesi√≥n
        self.user_sessions[phone_number] = {
            'pending_action': 'checkout',
            'timestamp': datetime.now(),
            'employee_id': employee.id
        }
        
        # Si la pol√≠tica de la empresa requiere ubicaci√≥n
        if self.company.location_required_for_attendance:
            return {
                "success": True,
                "message": "üìç Por favor comparte tu ubicaci√≥n para registrar tu salida",
                "quick_replies": [
                    {"text": "üìç Compartir ubicaci√≥n", "action": "send_location"},
                    {"text": "üìù Salida manual", "action": "manual_checkout"},
                    {"text": "‚ùå Cancelar", "action": "cancel"}
                ]
            }
        else:
            # Si no requiere ubicaci√≥n, registrar directamente
            return await self._complete_checkout(employee, phone_number, None, None, True)
    
    async def _complete_checkout(self, employee: PayrollEmployee, phone_number: str,
                              latitude: Optional[float], longitude: Optional[float],
                              is_valid_location: bool) -> Dict[str, Any]:
        """Completa el registro de salida"""
        try:
            # Limpiar sesi√≥n pendiente
            if phone_number in self.user_sessions:
                del self.user_sessions[phone_number]
            
            # Si la ubicaci√≥n no es v√°lida pero es requerida
            if not is_valid_location and self.company.location_required_for_attendance:
                return {
                    "success": False,
                    "message": "‚ùå No est√°s dentro del per√≠metro autorizado para registrar salida.",
                    "quick_replies": [
                        {"text": "üîÑ Reintentar", "action": "checkout"},
                        {"text": "üìù Solicitar excepci√≥n", "action": "exception_request"},
                        {"text": "üè† Men√∫ principal", "action": "main_menu"}
                    ]
                }
            
            # Verificar registro del d√≠a
            today = timezone.now().date()
            record = AttendanceRecord.objects.filter(
                employee=employee,
                date=today
            ).first()
            
            if not record or not record.check_in:
                # No hay registro de entrada
                return {
                    "success": False,
                    "message": "‚ùå No tienes registro de entrada hoy. Primero debes registrar tu entrada.",
                    "quick_replies": [
                        {"text": "‚úÖ Registrar entrada", "action": "checkin"},
                        {"text": "üìù Solicitar correcci√≥n", "action": "correction_request"}
                    ]
                }
                
            if record.check_out:
                # Ya tiene registro de salida
                formatted_time = record.check_out.strftime('%H:%M')
                return {
                    "success": True,
                    "message": f"‚ÑπÔ∏è Ya registraste tu salida hoy a las {formatted_time}.",
                    "quick_replies": [
                        {"text": "üìä Mi resumen hoy", "action": "day_summary"},
                        {"text": "üè† Men√∫ principal", "action": "main_menu"}
                    ]
                }
            
            # Registrar salida
            now = timezone.now()
            record.check_out = now
            
            # Guardar ubicaci√≥n si est√° disponible
            if latitude and longitude:
                record.check_out_location = {
                    'latitude': latitude,
                    'longitude': longitude,
                    'timestamp': now.isoformat()
                }
                
            # Calcular horas trabajadas
            if record.check_in:
                delta = now - record.check_in
                record.hours_worked = delta.total_seconds() / 3600  # Convertir a horas
                
            # Guardar registro
            record.save()
            
            # Formato amigable de la hora
            formatted_time = now.strftime('%H:%M:%S')
            
            # Calcular horas trabajadas con formato
            hours_worked = record.hours_worked or 0
            hours = int(hours_worked)
            minutes = int((hours_worked - hours) * 60)
            
            return {
                "success": True,
                "message": f"‚úÖ Salida registrada correctamente a las {formatted_time}.\n\n‚è±Ô∏è Horas trabajadas hoy: {hours}h {minutes}m",
                "quick_replies": [
                    {"text": "üìä Mi resumen semanal", "action": "week_summary"},
                    {"text": "üè† Men√∫ principal", "action": "main_menu"}
                ]
            }
            
        except Exception as e:
            logger.error(f"Error registrando salida: {str(e)}")
            return {
                "success": False,
                "message": f"‚ùå Error registrando salida: {str(e)}",
                "quick_replies": [
                    {"text": "üîÑ Reintentar", "action": "checkout"},
                    {"text": "üìû Contactar RH", "action": "contact_hr"}
                ]
            }
    
    # M√©todos para solicitudes de informaci√≥n
    
    async def _handle_payslip_request(self, employee: PayrollEmployee, phone_number: str) -> Dict[str, Any]:
        """Maneja solicitud de recibo de n√≥mina"""
        try:
            # Verificar periodos disponibles
            available_periods = PayrollPeriod.objects.filter(
                company=self.company,
                is_closed=True,
                start_date__gte=(timezone.now() - timedelta(days=90)).date()  # √öltimos 90 d√≠as
            ).order_by('-end_date')
            
            if not available_periods:
                return {
                    "success": True,
                    "message": "‚ÑπÔ∏è No hay periodos de n√≥mina cerrados disponibles en los √∫ltimos 90 d√≠as.",
                    "quick_replies": [
                        {"text": "üìû Contactar RH", "action": "contact_hr"},
                        {"text": "üè† Men√∫ principal", "action": "main_menu"}
                    ]
                }
            
            # Mostrar los √∫ltimos 3 periodos
            periods_display = []
            for i, period in enumerate(available_periods[:3]):
                start = period.start_date.strftime('%d/%m/%Y')
                end = period.end_date.strftime('%d/%m/%Y')
                periods_display.append(f"üìÑ Periodo {start} - {end}")
                
            # Crear mensaje con opciones
            message = "üìë Recibos de n√≥mina disponibles:\n\n" + "\n".join(periods_display)
            message += "\n\nSelecciona un periodo o solicita un rango espec√≠fico."
            
            # Opciones para los periodos
            quick_replies = []
            for i, period in enumerate(available_periods[:3]):
                start = period.start_date.strftime('%d/%m/%Y')
                end = period.end_date.strftime('%d/%m/%Y')
                label = f"Periodo {i+1}"
                action = f"payslip_{period.id}"
                quick_replies.append({"text": label, "action": action})
            
            # A√±adir opci√≥n de rango personalizado
            quick_replies.append({"text": "üìÜ Otro periodo", "action": "custom_period"})
            quick_replies.append({"text": "üè† Men√∫ principal", "action": "main_menu"})
            
            return {
                "success": True,
                "message": message,
                "quick_replies": quick_replies
            }
            
        except Exception as e:
            logger.error(f"Error en solicitud de recibo: {str(e)}")
            return {
                "success": False,
                "message": "‚ùå Error procesando tu solicitud de recibo de n√≥mina.",
                "quick_replies": [
                    {"text": "üîÑ Reintentar", "action": "payslip"},
                    {"text": "üìû Contactar RH", "action": "contact_hr"}
                ]
            }
    
    async def _handle_balance_inquiry(self, employee: PayrollEmployee, phone_number: str) -> Dict[str, Any]:
        """Maneja consulta de saldos (vacaciones, permisos, etc.)"""
        try:
            # Obtener balances del empleado
            vacation_days = self._calculate_vacation_balance(employee)
            sick_days = self._calculate_sick_days_balance(employee)
            permissions = self._calculate_permissions_balance(employee)
            
            # Formatear mensaje
            message = f"üìä BALANCE ACTUAL DE {employee.full_name.upper()}\n\n"
            message += f"üèñÔ∏è D√≠as de vacaciones: {vacation_days} d√≠as\n"
            message += f"ü§í D√≠as por enfermedad: {sick_days} d√≠as\n"
            message += f"üïí Permisos disponibles: {permissions} horas\n\n"
            
            # A√±adir saldos econ√≥micos si aplica
            if hasattr(employee, 'savings_balance') and employee.savings_balance:
                message += f"üí∞ Fondo de ahorro: ${employee.savings_balance:,.2f}\n"
                
            if hasattr(employee, 'loan_balance') and employee.loan_balance:
                message += f"üí∏ Saldo de pr√©stamos: ${employee.loan_balance:,.2f}\n"
                
            message += "\n¬øQu√© deseas hacer?"
            
            return {
                "success": True,
                "message": message,
                "quick_replies": [
                    {"text": "üèñÔ∏è Solicitar vacaciones", "action": "vacation_request"},
                    {"text": "üïí Solicitar permiso", "action": "permission_request"},
                    {"text": "üè† Men√∫ principal", "action": "main_menu"}
                ]
            }
            
        except Exception as e:
            logger.error(f"Error consultando balances: {str(e)}")
            return {
                "success": False,
                "message": "‚ùå Error consultando tus balances.",
                "quick_replies": [
                    {"text": "üîÑ Reintentar", "action": "balance"},
                    {"text": "üìû Contactar RH", "action": "contact_hr"}
                ]
            }
    
    def _calculate_vacation_balance(self, employee: PayrollEmployee) -> int:
        """Calcula balance de vacaciones del empleado"""
        # Implementar c√°lculo real de vacaciones seg√∫n antig√ºedad y ley
        # Por ahora retornamos un valor de ejemplo
        return 12
    
    def _calculate_sick_days_balance(self, employee: PayrollEmployee) -> int:
        """Calcula balance de d√≠as por enfermedad"""
        # Implementar c√°lculo real
        return 7
    
    def _calculate_permissions_balance(self, employee: PayrollEmployee) -> int:
        """Calcula balance de horas de permiso"""
        # Implementar c√°lculo real
        return 16
    
    # M√©todos para manejar botones y acciones
    
    async def _process_button_response(self, employee: PayrollEmployee, 
                                    phone_number: str, button_id: str) -> Dict[str, Any]:
        """Procesa respuesta de bot√≥n"""
        try:
            # Determinar acci√≥n basada en ID del bot√≥n
            action = button_id.lower()
            
            # Mapeo de acciones a m√©todos
            if action == "checkin":
                return await self._handle_checkin(employee, phone_number)
                
            elif action == "checkout":
                return await self._handle_checkout(employee, phone_number)
                
            elif action == "payslip":
                return await self._handle_payslip_request(employee, phone_number)
                
            elif action == "balance":
                return await self._handle_balance_inquiry(employee, phone_number)
                
            elif action == "schedule":
                return await self._handle_schedule_inquiry(employee, phone_number)
                
            elif action == "help":
                return await self._handle_help_command(employee, phone_number)
                
            elif action == "main_menu":
                return await self._create_main_menu(employee, phone_number)
                
            elif action == "cancel":
                # Limpiar sesi√≥n pendiente
                if phone_number in self.user_sessions:
                    del self.user_sessions[phone_number]
                    
                return {
                    "success": True,
                    "message": "‚ùå Operaci√≥n cancelada.",
                    "quick_replies": [
                        {"text": "üè† Men√∫ principal", "action": "main_menu"},
                        {"text": "‚ùì Ayuda", "action": "help"}
                    ]
                }
                
            elif action.startswith("payslip_"):
                # Extraer ID del periodo
                try:
                    period_id = int(action.split('_')[1])
                    return await self._send_payslip(employee, phone_number, period_id)
                except (ValueError, IndexError):
                    return await self._handle_payslip_request(employee, phone_number)
            
            # Aqu√≠ se pueden a√±adir m√°s mappings seg√∫n sea necesario
            else:
                return await self._handle_unknown_command(employee, phone_number, action)
                
        except Exception as e:
            logger.error(f"Error procesando bot√≥n: {str(e)}")
            return {
                "success": False,
                "message": "‚ùå Error procesando tu selecci√≥n.",
                "quick_replies": [
                    {"text": "üîÑ Reintentar", "action": "retry"},
                    {"text": "üè† Men√∫ principal", "action": "main_menu"}
                ]
            }
    
    async def _process_list_response(self, employee: PayrollEmployee, 
                                  phone_number: str, list_item_id: str) -> Dict[str, Any]:
        """Procesa respuesta de lista"""
        # Similar a _process_button_response pero para selecciones de listas
        # Este m√©todo es similar al anterior, se implementar√≠a seg√∫n necesidades espec√≠ficas
        pass
        
    async def _create_main_menu(self, employee: PayrollEmployee, phone_number: str) -> Dict[str, Any]:
        """Crea men√∫ principal basado en rol del usuario"""
        # Determinar rol del empleado
        is_supervisor = employee.has_role(PAYROLL_ROLES.SUPERVISOR)
        is_hr = employee.has_role(PAYROLL_ROLES.HR)
        
        # Opciones base para todos
        message = f"üëã Hola {employee.first_name}!\n\nüè¢ *{self.company.name}*\n"
        message += "\nüì± *MEN√ö PRINCIPAL*\n"
        
        # Opciones para empleados
        options = [
            {"text": "‚úÖ Registrar entrada", "action": "checkin"},
            {"text": "üö™ Registrar salida", "action": "checkout"},
            {"text": "üìÑ Recibo de n√≥mina", "action": "payslip"},
            {"text": "üìä Mis balances", "action": "balance"}
        ]
        
        # Opciones adicionales para supervisores
        if is_supervisor:
            options.extend([
                {"text": "üë• Mi equipo", "action": "team"},
                {"text": "üìã Aprobar solicitudes", "action": "pending_approvals"}
            ])
            
        # Opciones adicionales para RH
        if is_hr:
            options.extend([
                {"text": "üìà Dashboard RH", "action": "hr_dashboard"},
                {"text": "üìä Reportes", "action": "hr_reports"}
            ])
        
        # Opciones generales al final
        options.extend([
            {"text": "‚ùì Ayuda", "action": "help"},
            {"text": "üìû Contactar RH", "action": "contact_hr"}
        ])
        
        # Limitar a m√°ximo 10 opciones
        if len(options) > 10:
            options = options[:10]
            
        return {
            "success": True,
            "message": message,
            "quick_replies": options
        }
    
    async def _handle_help_command(self, employee: PayrollEmployee, phone_number: str) -> Dict[str, Any]:
        """Maneja comando de ayuda"""
        # Determinar rol del empleado para personalizar ayuda
        is_supervisor = employee.has_role(PAYROLL_ROLES.SUPERVISOR)
        is_hr = employee.has_role(PAYROLL_ROLES.HR)
        
        message = f"‚ùì *AYUDA* - {self.company.name}\n\n"
        
        # Comandos b√°sicos para todos
        message += "*COMANDOS B√ÅSICOS:*\n"
        message += "‚Ä¢ 'entrada' - Registrar entrada\n"
        message += "‚Ä¢ 'salida' - Registrar salida\n"
        message += "‚Ä¢ 'recibo' - Solicitar recibo de n√≥mina\n"
        message += "‚Ä¢ 'balance' - Consultar balances\n"
        message += "‚Ä¢ 'horario' - Ver tu horario\n"
        message += "‚Ä¢ 'men√∫' - Ver men√∫ principal\n\n"
        
        # Comandos para supervisores
        if is_supervisor:
            message += "*COMANDOS DE SUPERVISOR:*\n"
            message += "‚Ä¢ 'equipo' - Ver estado de tu equipo\n"
            message += "‚Ä¢ 'aprobar' - Revisar solicitudes pendientes\n"
            message += "‚Ä¢ 'reporte equipo' - Generar reporte de equipo\n\n"
        
        # Comandos para RH
        if is_hr:
            message += "*COMANDOS DE RH:*\n"
            message += "‚Ä¢ 'dashboard' - Ver dashboard de RH\n"
            message += "‚Ä¢ 'reporte' - Generar reportes\n"
            message += "‚Ä¢ 'enviar reporte' - Enviar reporte por email\n\n"
        
        # Informaci√≥n de contacto
        message += "*CONTACTO:*\n"
        message += f"‚Ä¢ RH: {self.company.hr_email or 'rh@empresa.com'}\n"
        message += f"‚Ä¢ Soporte: {self.company.support_email or 'soporte@empresa.com'}"
        
        return {
            "success": True,
            "message": message,
            "quick_replies": [
                {"text": "üè† Men√∫ principal", "action": "main_menu"},
                {"text": "üìû Contactar RH", "action": "contact_hr"}
            ]
        }
    
    async def _handle_unknown_command(self, employee: PayrollEmployee, 
                                   phone_number: str, command: str) -> Dict[str, Any]:
        """Maneja comandos desconocidos"""
        return {
            "success": True,
            "message": f"Lo siento, no entiendo el comando '{command}'.\n\n¬øEn qu√© puedo ayudarte?",
            "quick_replies": [
                {"text": "‚ùì Ayuda", "action": "help"},
                {"text": "üè† Men√∫ principal", "action": "main_menu"}
            ]
        }
    
    # M√©todos auxiliares
    
    def _validate_office_location(self, employee: PayrollEmployee, 
                                user_lat: Decimal, user_lon: Decimal) -> bool:
        """Valida que el empleado est√© cerca de la oficina"""
        # Obtener ubicaci√≥n de la oficina
        office_location = employee.office_location or {}
        office_lat = Decimal(str(office_location.get('latitude', 0)))
        office_lon = Decimal(str(office_location.get('longitude', 0)))
        
        if office_lat == 0 or office_lon == 0:
            # Si no hay ubicaci√≥n configurada, permitir
            return True
        
        # Calcular distancia (f√≥rmula de Haversine simplificada)
        distance = self._calculate_distance(user_lat, user_lon, office_lat, office_lon)
        
        # Permitir dentro del radio configurado (default 100m)
        max_distance = self.company.max_location_distance or 0.1  # km
        return distance <= max_distance
    
    def _calculate_distance(self, lat1: Decimal, lon1: Decimal, 
                           lat2: Decimal, lon2: Decimal) -> float:
        """Calcula distancia entre dos puntos en km (Haversine)"""
        from math import radians, cos, sin, asin, sqrt
        
        # Convertir a radianes
        lat1, lon1, lat2, lon2 = map(radians, [float(lat1), float(lon1), float(lat2), float(lon2)])
        
        # F√≥rmula de Haversine
        dlat = lat2 - lat1
        dlon = lon2 - lon1
        a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
        c = 2 * asin(sqrt(a))
        r = 6371  # Radio de la Tierra en km
        
        return c * r
        
    # =========================================
    # M√©todos para soporte multiling√ºe
    # =========================================
    
    def _get_user_language(self, phone_number: str) -> str:
        """Obtiene el idioma preferido del usuario o el idioma por defecto"""
        return self.user_languages.get(phone_number, self.messaging_config.get('default_language', DEFAULT_LANGUAGE))
    
    def _set_user_language(self, phone_number: str, language: str) -> None:
        """Establece el idioma preferido para un usuario"""
        if language in SUPPORTED_LANGUAGES:
            self.user_languages[phone_number] = language
            logger.info(f"Idioma cambiado para {phone_number}: {language}")
        else:
            logger.warning(f"Intento de establecer idioma no soportado: {language}")
    
    def _detect_message_language(self, message: str) -> str:
        """Detecta el idioma del mensaje"""
        return detect_language(message)
    
    def _check_language_change_command(self, phone_number: str, message: str) -> bool:
        """Verifica si el mensaje es un comando para cambiar el idioma"""
        message = message.lower().strip()
        
        # Comandos expl√≠citos de cambio de idioma
        if message in ['idioma', 'language', 'langue', 'idioma']:
            # Mostrar men√∫ de selecci√≥n de idioma
            return False  # No es cambio directo, sino solicitud de men√∫
            
        # Cambios directos de idioma
        if message in ['espa√±ol', 'spanish', 'es', 'lang:es', 'language:es']:
            self._set_user_language(phone_number, 'es')
            return True
        elif message in ['english', 'ingl√©s', 'ingles', 'en', 'lang:en', 'language:en']:
            self._set_user_language(phone_number, 'en')
            return True
        elif message in ['fran√ßais', 'francais', 'french', 'fr', 'lang:fr', 'language:fr']:
            self._set_user_language(phone_number, 'fr')
            return True
        elif message in ['portugu√™s', 'portugues', 'portuguese', 'pt', 'lang:pt', 'language:pt']:
            self._set_user_language(phone_number, 'pt')
            return True
            
        return False
    
    def _create_language_changed_response(self, phone_number: str) -> Dict[str, Any]:
        """Crea respuesta de confirmaci√≥n de cambio de idioma"""
        lang = self._get_user_language(phone_number)
        
        # Crear mensaje de bienvenida en el nuevo idioma
        message = get_message('system', 'language_changed', lang)
        welcome = get_message('system', 'welcome', lang)
        
        # A√±adir opciones de men√∫ principal
        help_text = get_button_text('help', lang)
        menu_text = get_button_text('main_menu', lang)
        
        return {
            "success": True,
            "message": f"{message}\n\n{welcome}",
            "quick_replies": [
                {"text": f"‚ùì {help_text}", "action": "help"},
                {"text": f"üè† {menu_text}", "action": "main_menu"}
            ]
        }
    
    def _handle_language_menu(self, phone_number: str) -> Dict[str, Any]:
        """Muestra men√∫ de selecci√≥n de idioma"""
        lang = self._get_user_language(phone_number)
        
        message = "üåé *" + get_message('system', 'language_menu', lang, default="Selecciona tu idioma / Select your language") + "*\n\n"
        
        # A√±adir opciones para cada idioma soportado
        for lang_code, lang_name in SUPPORTED_LANGUAGES.items():
            message += f"‚Ä¢ {lang_name}: env√≠a '{lang_code}'\n"
        
        return {
            "success": True,
            "message": message,
            "quick_replies": [
                {"text": "üá™üá∏ Espa√±ol", "action": "lang_es"},
                {"text": "üá∫üá∏ English", "action": "lang_en"},
                {"text": "üá´üá∑ Fran√ßais", "action": "lang_fr"},
                {"text": "üáßüá∑ Portugu√™s", "action": "lang_pt"}
            ]
        }
    
    # M√©todos adicionales a implementar:
    # - _handle_schedule_inquiry
    # - _handle_severance_calculation
    # - _handle_climate_inquiry
    # - _handle_request_creation
    # - _handle_role_switch
    # - _send_payslip
    # etc.
