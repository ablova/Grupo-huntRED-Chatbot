# /home/pablo/app/com/chatbot/integrations/handlers.py
#
# M√≥dulo de manejadores para el chatbot.
# Incluye funcionalidades para manejo de mensajes, gamificaci√≥n, correo electr√≥nico y m√°s.
# Optimizado para bajo uso de CPU, escalabilidad, y robustez frente a fallos.

import logging
from typing import Dict, List, Optional, Any
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum

from app.com.chatbot.models.chat_state import ChatState
from app.com.chatbot.models.profile import Profile
from app.com.chatbot.integrations.services import MENU_OPTIONS_BY_BU, EVALUATIONS_MENU
from app.com.chatbot.integrations.services import MessageService

from app.com.chatbot.workflow.assessments.professional_dna import (
    ProfessionalDNAAnalysis,
    BusinessUnit,
    QuestionCategory,
    AnalysisType,
    GenerationalAnalysis
)
from app.com.chatbot.workflow.assessments.cultural import (
    CulturalFitWorkflow,
    CulturalAnalysis
)
from app.com.chatbot.workflow.assessments.talent import (
    TalentAnalysisWorkflow,
    TalentAnalysis
)
from app.com.chatbot.workflow.assessments.personality import (
    PersonalityAssessment,
    PersonalityAnalysis
)
from app.com.chatbot.workflow.assessments.generational import (
    GenerationalAnalysis,
    GenerationalPatterns,
    GenerationalInsights
)

from app.com.chatbot.workflow.reports.professional_dna import ProfessionalDNAReport
from app.com.chatbot.workflow.reports.cultural import CulturalReport
from app.com.chatbot.workflow.reports.talent import TalentReport
from app.com.chatbot.workflow.reports.personality import PersonalityReport
from app.com.chatbot.workflow.reports.generational import GenerationalReport

from app.com.chatbot.workflow.analysis.leadership import LeadershipAnalysis
from app.com.chatbot.workflow.analysis.innovation import InnovationAnalysis
from app.com.chatbot.workflow.analysis.communication import CommunicationAnalysis
from app.com.chatbot.workflow.analysis.resilience import ResilienceAnalysis
from app.com.chatbot.workflow.analysis.results import ResultsAnalysis

class MenuHandler:
    def __init__(self, service: MessageService):
        self.service = service
        self.logger = logging.getLogger(__name__)

    async def _handle_create_profile(self, platform: str, user_id: str) -> bool:
        """Maneja la creaci√≥n inicial del perfil."""
        try:
            # Verificar si ya existe un perfil
            profile = await Profile.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()

            if profile:
                message = "üë§ Ya tienes un perfil creado. ¬øQu√© deseas hacer?"
                buttons = [
                    {"title": "‚úèÔ∏è Editar Perfil", "payload": "editar_perfil"},
                    {"title": "üëÄ Ver Perfil", "payload": "ver_perfil"},
                    {"title": "üìä Ver Evaluaciones", "payload": "ver_evaluaciones"},
                    {"title": "üîô Volver al Men√∫", "payload": "menu"}
                ]
                return await self.service.send_options(platform, user_id, message, buttons)

            # Iniciar proceso de creaci√≥n de perfil
            message = "üë§ *Creaci√≥n de Perfil*\n\n"
            message += "Para brindarte la mejor experiencia, necesitamos crear tu perfil profesional.\n\n"
            message += "Este perfil nos ayudar√° a:\n"
            message += "‚Ä¢ Personalizar tus evaluaciones\n"
            message += "‚Ä¢ Recomendar oportunidades relevantes\n"
            message += "‚Ä¢ Guiar tu desarrollo profesional\n\n"
            message += "¬øDeseas comenzar con la creaci√≥n de tu perfil?"

            buttons = [
                {"title": "‚úÖ Comenzar", "payload": "start_profile_creation"},
                {"title": "‚ùå M√°s tarde", "payload": "menu"}
            ]

            # Actualizar estado del chat
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_profile_creation_confirmation"
                await chat_state.asave()

            return await self.service.send_options(platform, user_id, message, buttons)

        except Exception as e:
            self.logger.error(f"Error iniciando creaci√≥n de perfil: {str(e)}")
            return False

    async def _handle_start_profile_creation(self, platform: str, user_id: str) -> bool:
        """Maneja el inicio del proceso de creaci√≥n de perfil."""
        try:
            message = "üë§ *Creaci√≥n de Perfil*\n\n"
            message += "Por favor, proporciona la siguiente informaci√≥n:\n\n"
            message += "1Ô∏è‚É£ Nombre completo\n"
            message += "2Ô∏è‚É£ Correo electr√≥nico\n"
            message += "3Ô∏è‚É£ Tel√©fono\n"
            message += "4Ô∏è‚É£ Ubicaci√≥n\n"
            message += "5Ô∏è‚É£ A√±os de experiencia\n"
            message += "6Ô∏è‚É£ Educaci√≥n\n"
            message += "7Ô∏è‚É£ Habilidades principales\n\n"
            message += "Escribe 'comenzar' para iniciar el proceso."

            # Actualizar estado del chat
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_profile_creation"
                await chat_state.asave()

            return await self.service.send_message(platform, user_id, message)

        except Exception as e:
            self.logger.error(f"Error iniciando proceso de creaci√≥n de perfil: {str(e)}")
            return False

    async def _handle_edit_profile(self, platform: str, user_id: str) -> bool:
        """Maneja la edici√≥n del perfil existente."""
        try:
            profile = await Profile.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()

            if not profile:
                message = "‚ùå No tienes un perfil creado. ¬øDeseas crear uno?"
                buttons = [
                    {"title": "üìù Crear Perfil", "payload": "crear_perfil"},
                    {"title": "‚ùå Cancelar", "payload": "menu"}
                ]
                return await self.service.send_options(platform, user_id, message, buttons)

            # Mostrar campos editables
            message = "‚úèÔ∏è *Editar Perfil*\n\nSelecciona el campo que deseas editar:\n\n"
            message += "1Ô∏è‚É£ Nombre completo\n"
            message += "2Ô∏è‚É£ Correo electr√≥nico\n"
            message += "3Ô∏è‚É£ Tel√©fono\n"
            message += "4Ô∏è‚É£ Ubicaci√≥n\n"
            message += "5Ô∏è‚É£ A√±os de experiencia\n"
            message += "6Ô∏è‚É£ Educaci√≥n\n"
            message += "7Ô∏è‚É£ Habilidades principales\n\n"
            message += "Escribe el n√∫mero del campo que deseas editar."

            # Actualizar estado del chat
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_profile_edit"
                await chat_state.asave()

            return await self.service.send_message(platform, user_id, message)

        except Exception as e:
            self.logger.error(f"Error iniciando edici√≥n de perfil: {str(e)}")
            return False

    async def _handle_view_profile(self, platform: str, user_id: str) -> bool:
        """Maneja la visualizaci√≥n del perfil."""
        try:
            profile = await Profile.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()

            if not profile:
                message = "‚ùå No tienes un perfil creado. ¬øDeseas crear uno?"
                buttons = [
                    {"title": "üìù Crear Perfil", "payload": "crear_perfil"},
                    {"title": "‚ùå Cancelar", "payload": "menu"}
                ]
                return await self.service.send_options(platform, user_id, message, buttons)

            # Construir mensaje con informaci√≥n del perfil
            message = "üë§ *Tu Perfil Profesional*\n\n"
            message += f"*Nombre:* {profile.name}\n"
            message += f"*Email:* {profile.email}\n"
            message += f"*Tel√©fono:* {profile.phone}\n"
            message += f"*Ubicaci√≥n:* {profile.location}\n"
            message += f"*Experiencia:* {profile.experience} a√±os\n"
            message += f"*Educaci√≥n:* {profile.education}\n"
            message += f"*Habilidades:* {', '.join(profile.skills)}\n\n"
            
            # Agregar botones de acci√≥n
            buttons = [
                {"title": "‚úèÔ∏è Editar Perfil", "payload": "editar_perfil"},
                {"title": "üìä Ver Evaluaciones", "payload": "ver_evaluaciones"},
                {"title": "üîô Volver al Men√∫", "payload": "menu"}
            ]

            return await self.service.send_options(platform, user_id, message, buttons)

        except Exception as e:
            self.logger.error(f"Error mostrando perfil: {str(e)}")
            return False

    async def handle_menu(self, platform: str, user_id: str, payload: str) -> bool:
        """Maneja las interacciones con el men√∫ principal y submen√∫s."""
        try:
            # Manejar navegaci√≥n del men√∫ principal
            if payload == "menu_prev":
                return await self._handle_menu_navigation(platform, user_id, "prev")
            elif payload == "menu_next":
                return await self._handle_menu_navigation(platform, user_id, "next")
            elif payload == "menu_search":
                return await self._handle_menu_search(platform, user_id)
            elif payload == "menu":
                return await self.service.send_menu(platform, user_id)

            # Verificar si es un submen√∫
            if payload.startswith("search_"):
                parent_payload = payload.replace("search_", "")
                return await self._handle_submenu_search(platform, user_id, parent_payload)

            # Obtener el men√∫ actual del usuario
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()

            if not chat_state:
                self.logger.error(f"No se encontr√≥ ChatState para {user_id}")
                return False

            # Verificar si el payload corresponde a una opci√≥n principal
            bu_name = self.service.business_unit.name.lower()
            menu_options = MENU_OPTIONS_BY_BU.get(bu_name, [])
            
            for option in menu_options:
                if option["payload"] == payload:
                    # Si la opci√≥n tiene submen√∫, mostrarlo
                    if "submenu" in option:
                        return await self.service.send_submenu(platform, user_id, payload)
                    # Si no tiene submen√∫, procesar la acci√≥n directamente
                    return await self._handle_menu_action(platform, user_id, payload)

            # Si no se encontr√≥ en el men√∫ principal, buscar en submen√∫s
            for option in menu_options:
                if "submenu" in option:
                    for suboption in option["submenu"]:
                        if suboption["payload"] == payload:
                            return await self._handle_menu_action(platform, user_id, payload)

            self.logger.warning(f"Payload no reconocido: {payload}")
            return False

        except Exception as e:
            self.logger.error(f"Error manejando men√∫: {str(e)}")
            return False

    async def _handle_menu_navigation(self, platform: str, user_id: str, direction: str) -> bool:
        """Maneja la navegaci√≥n entre p√°ginas del men√∫."""
        try:
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()

            if not chat_state:
                return False

            # Obtener el men√∫ actual
            current_page = chat_state.menu_page or 0
            bu_name = self.service.business_unit.name.lower()
            menu_options = MENU_OPTIONS_BY_BU.get(bu_name, [])
            
            # Calcular nueva p√°gina
            if direction == "prev":
                new_page = max(0, current_page - 1)
            else:  # next
                new_page = min(len(menu_options) - 1, current_page + 1)

            # Actualizar estado
            chat_state.menu_page = new_page
            await chat_state.asave()

            # Enviar men√∫ actualizado
            return await self.service.send_menu(platform, user_id)

        except Exception as e:
            self.logger.error(f"Error en navegaci√≥n de men√∫: {str(e)}")
            return False

    async def _handle_menu_search(self, platform: str, user_id: str) -> bool:
        """Maneja la b√∫squeda en el men√∫ principal."""
        try:
            # Enviar mensaje solicitando t√©rmino de b√∫squeda
            message = "üîç *B√∫squeda en Men√∫*\n\nPor favor, escribe el t√©rmino que deseas buscar:"
            await self.service.send_message(platform, user_id, message)
            
            # Actualizar estado para esperar t√©rmino de b√∫squeda
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_menu_search"
                await chat_state.asave()
            
            return True

        except Exception as e:
            self.logger.error(f"Error en b√∫squeda de men√∫: {str(e)}")
            return False

    async def _handle_submenu_search(self, platform: str, user_id: str, parent_payload: str) -> bool:
        """Maneja la b√∫squeda en un submen√∫ espec√≠fico."""
        try:
            # Enviar mensaje solicitando t√©rmino de b√∫squeda
            message = f"üîç *B√∫squeda en Submen√∫*\n\nPor favor, escribe el t√©rmino que deseas buscar:"
            await self.service.send_message(platform, user_id, message)
            
            # Actualizar estado para esperar t√©rmino de b√∫squeda
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = f"waiting_submenu_search_{parent_payload}"
                await chat_state.asave()
            
            return True

        except Exception as e:
            self.logger.error(f"Error en b√∫squeda de submen√∫: {str(e)}")
            return False

    async def _handle_menu_action(self, platform: str, user_id: str, payload: str) -> bool:
        """Maneja la acci√≥n seleccionada en el men√∫ o submen√∫."""
        try:
            # Mapeo de acciones espec√≠ficas
            action_handlers = {
                "ver_perfil": self._handle_view_profile,
                "editar_perfil": self._handle_edit_profile,
                "ver_evaluaciones": self._handle_view_evaluations,
                "prueba_personalidad": self._handle_personality_test,
                "analisis_talento": self._handle_talent_analysis,
                "analisis_cultural": self._handle_cultural_analysis,
                "analisis_generacional": self._handle_generational_analysis,
                "analisis_motivacional": self._handle_motivational_analysis,
                "analisis_estilos": self._handle_work_style_analysis,
                "analisis_desarrollo": self._handle_professional_development,
                "analisis_adaptabilidad": self._handle_adaptability_analysis,
                "subir_cv": self._handle_upload_cv,
                "ver_cv": self._handle_view_cv,
                "editar_cv": self._handle_edit_cv,
                "buscar_vacantes": self._handle_search_jobs,
                "vacantes_recomendadas": self._handle_recommended_jobs,
                "mis_postulaciones": self._handle_my_applications,
                "nueva_entrevista": self._handle_schedule_interview,
                "ver_entrevistas": self._handle_view_interviews,
                "modificar_entrevista": self._handle_modify_interview,
                "neto_a_bruto": self._handle_net_to_gross,
                "bruto_a_neto": self._handle_gross_to_net,
                "chat_asesor": self._handle_chat_advisor,
                "agendar_cita": self._handle_schedule_appointment,
                "ver_mentores": self._handle_view_mentors,
                "agendar_sesion": self._handle_schedule_mentoring,
                "faq": self._handle_faq,
                "guias": self._handle_guides,
                "tutoriales": self._handle_tutorials
            }

            # Obtener el manejador espec√≠fico
            handler = action_handlers.get(payload)
            if handler:
                return await handler(platform, user_id)
            
            self.logger.warning(f"No se encontr√≥ manejador para la acci√≥n: {payload}")
            return False

        except Exception as e:
            self.logger.error(f"Error manejando acci√≥n de men√∫: {str(e)}")
            return False

    # Implementaci√≥n de manejadores espec√≠ficos
    async def _handle_view_evaluations(self, platform: str, user_id: str) -> bool:
        """Maneja la visualizaci√≥n de evaluaciones disponibles."""
        try:
            message = "üìä *Evaluaciones Disponibles*\n\n"
            message += "Selecciona el tipo de evaluaci√≥n que deseas realizar:\n\n"
            message += "1Ô∏è‚É£ Evaluaci√≥n de Personalidad\n"
            message += "2Ô∏è‚É£ Evaluaci√≥n de Talento\n"
            message += "3Ô∏è‚É£ Evaluaci√≥n Cultural\n\n"
            message += "Cada evaluaci√≥n te ayudar√° a conocerte mejor y potenciar tu desarrollo profesional."

            buttons = [
                {"title": "üë§ Personalidad", "payload": "personality_test"},
                {"title": "üí´ Talento", "payload": "talent_analysis"},
                {"title": "üåç Cultural", "payload": "cultural_analysis"},
                {"title": "üîô Volver", "payload": "menu"}
            ]

            return await self.service.send_options(platform, user_id, message, buttons)

        except Exception as e:
            self.logger.error(f"Error mostrando evaluaciones: {str(e)}")
            return False

    async def _handle_personality_test(self, platform: str, user_id: str) -> bool:
        """Maneja la evaluaci√≥n de personalidad."""
        try:
            from app.com.chatbot.workflow.evaluaciones.personality_evaluation import PersonalityEvaluation
            
            # Obtener perfil del usuario
            profile = await Profile.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()

            if not profile:
                message = "‚ùå Necesitas tener un perfil creado para realizar la evaluaci√≥n."
                buttons = [
                    {"title": "üìù Crear Perfil", "payload": "crear_perfil"},
                    {"title": "üîô Volver", "payload": "ver_evaluaciones"}
                ]
                return await self.service.send_options(platform, user_id, message, buttons)

            # Iniciar evaluaci√≥n
            evaluator = PersonalityEvaluation()
            message = "üë§ *Evaluaci√≥n de Personalidad*\n\n"
            message += "Esta evaluaci√≥n analizar√°:\n"
            message += "‚Ä¢ Liderazgo y toma de decisiones\n"
            message += "‚Ä¢ Adaptabilidad y flexibilidad\n"
            message += "‚Ä¢ Gesti√≥n y organizaci√≥n\n\n"
            message += "¬øDeseas comenzar la evaluaci√≥n?"

            buttons = [
                {"title": "‚úÖ Comenzar", "payload": "start_personality_test"},
                {"title": "‚ùå Cancelar", "payload": "ver_evaluaciones"}
            ]

            return await self.service.send_options(platform, user_id, message, buttons)

        except Exception as e:
            self.logger.error(f"Error iniciando evaluaci√≥n de personalidad: {str(e)}")
            return False

    async def _handle_talent_analysis(self, platform: str, user_id: str) -> bool:
        """Maneja la evaluaci√≥n de talento."""
        try:
            from app.com.chatbot.workflow.evaluaciones.talent_evaluation import TalentEvaluation
            
            # Obtener perfil del usuario
            profile = await Profile.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()

            if not profile:
                message = "‚ùå Necesitas tener un perfil creado para realizar la evaluaci√≥n."
                buttons = [
                    {"title": "üìù Crear Perfil", "payload": "crear_perfil"},
                    {"title": "üîô Volver", "payload": "ver_evaluaciones"}
                ]
                return await self.service.send_options(platform, user_id, message, buttons)

            # Iniciar evaluaci√≥n
            evaluator = TalentEvaluation()
            message = "üí´ *Evaluaci√≥n de Talento*\n\n"
            message += "Esta evaluaci√≥n analizar√°:\n"
            message += "‚Ä¢ Estrategia y visi√≥n\n"
            message += "‚Ä¢ Innovaci√≥n y creatividad\n"
            message += "‚Ä¢ Habilidades t√©cnicas\n\n"
            message += "¬øDeseas comenzar la evaluaci√≥n?"

            buttons = [
                {"title": "‚úÖ Comenzar", "payload": "start_talent_analysis"},
                {"title": "‚ùå Cancelar", "payload": "ver_evaluaciones"}
            ]

            return await self.service.send_options(platform, user_id, message, buttons)

        except Exception as e:
            self.logger.error(f"Error iniciando evaluaci√≥n de talento: {str(e)}")
            return False

    async def _handle_cultural_analysis(self, platform: str, user_id: str) -> bool:
        """Maneja la evaluaci√≥n cultural."""
        try:
            from app.com.chatbot.workflow.evaluaciones.cultural_evaluation import CulturalEvaluation
            
            # Obtener perfil del usuario
            profile = await Profile.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()

            if not profile:
                message = "‚ùå Necesitas tener un perfil creado para realizar la evaluaci√≥n."
                buttons = [
                    {"title": "üìù Crear Perfil", "payload": "crear_perfil"},
                    {"title": "üîô Volver", "payload": "ver_evaluaciones"}
                ]
                return await self.service.send_options(platform, user_id, message, buttons)

            # Iniciar evaluaci√≥n
            evaluator = CulturalEvaluation()
            message = "üåç *Evaluaci√≥n Cultural*\n\n"
            message += "Esta evaluaci√≥n analizar√°:\n"
            message += "‚Ä¢ Valores y principios\n"
            message += "‚Ä¢ Adaptabilidad cultural\n"
            message += "‚Ä¢ Comunicaci√≥n intercultural\n\n"
            message += "¬øDeseas comenzar la evaluaci√≥n?"

            buttons = [
                {"title": "‚úÖ Comenzar", "payload": "start_cultural_analysis"},
                {"title": "‚ùå Cancelar", "payload": "ver_evaluaciones"}
            ]

            return await self.service.send_options(platform, user_id, message, buttons)

        except Exception as e:
            self.logger.error(f"Error iniciando evaluaci√≥n cultural: {str(e)}")
            return False

    async def _handle_generational_analysis(self, platform: str, user_id: str) -> bool:
        """Maneja el an√°lisis generacional."""
        try:
            # Enviar mensaje indicando que se est√° realizando el an√°lisis generacional
            message = "üë®‚Äçüë©‚Äçüëß‚Äçüë¶ *An√°lisis Generacional*\n\nPor favor, responde las siguientes preguntas:"
            await self.service.send_message(platform, user_id, message)
            
            # Actualizar estado para esperar respuestas del an√°lisis
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_generational_analysis"
                await chat_state.asave()
            
            return True

        except Exception as e:
            self.logger.error(f"Error manejando an√°lisis generacional: {str(e)}")
            return False

    async def _handle_motivational_analysis(self, platform: str, user_id: str) -> bool:
        """Maneja el an√°lisis motivacional."""
        try:
            # Enviar mensaje indicando que se est√° realizando el an√°lisis motivacional
            message = "üåü *An√°lisis Motivacional*\n\nPor favor, responde las siguientes preguntas:"
            await self.service.send_message(platform, user_id, message)
            
            # Actualizar estado para esperar respuestas del an√°lisis
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_motivational_analysis"
                await chat_state.asave()
            
            return True

        except Exception as e:
            self.logger.error(f"Error manejando an√°lisis motivacional: {str(e)}")
            return False

    async def _handle_work_style_analysis(self, platform: str, user_id: str) -> bool:
        """Maneja el an√°lisis de estilo de trabajo."""
        try:
            # Enviar mensaje indicando que se est√° realizando el an√°lisis de estilo de trabajo
            message = "üíº *An√°lisis de Estilo de Trabajo*\n\nPor favor, responde las siguientes preguntas:"
            await self.service.send_message(platform, user_id, message)
            
            # Actualizar estado para esperar respuestas del an√°lisis
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_work_style_analysis"
                await chat_state.asave()
            
            return True

        except Exception as e:
            self.logger.error(f"Error manejando an√°lisis de estilo de trabajo: {str(e)}")
            return False

    async def _handle_professional_development(self, platform: str, user_id: str) -> bool:
        """Maneja el an√°lisis de desarrollo profesional."""
        try:
            # Enviar mensaje indicando que se est√° realizando el an√°lisis de desarrollo profesional
            message = "üå± *An√°lisis de Desarrollo Profesional*\n\nPor favor, responde las siguientes preguntas:"
            await self.service.send_message(platform, user_id, message)
            
            # Actualizar estado para esperar respuestas del an√°lisis
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_professional_development"
                await chat_state.asave()
            
            return True

        except Exception as e:
            self.logger.error(f"Error manejando an√°lisis de desarrollo profesional: {str(e)}")
            return False

    async def _handle_adaptability_analysis(self, platform: str, user_id: str) -> bool:
        """Maneja el an√°lisis de adaptabilidad."""
        try:
            # Enviar mensaje indicando que se est√° realizando el an√°lisis de adaptabilidad
            message = "üå± *An√°lisis de Adaptabilidad*\n\nPor favor, responde las siguientes preguntas:"
            await self.service.send_message(platform, user_id, message)
            
            # Actualizar estado para esperar respuestas del an√°lisis
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_adaptability_analysis"
                await chat_state.asave()
            
            return True

        except Exception as e:
            self.logger.error(f"Error manejando an√°lisis de adaptabilidad: {str(e)}")
            return False

    async def _handle_upload_cv(self, platform: str, user_id: str) -> bool:
        """Maneja la carga de CV."""
        try:
            # Enviar mensaje solicitando CV
            message = "üìÑ *Carga de CV*\n\nPor favor, sube tu CV en formato PDF o Word:"
            await self.service.send_message(platform, user_id, message)
            
            # Actualizar estado para esperar CV
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_upload_cv"
                await chat_state.asave()
            
            return True

        except Exception as e:
            self.logger.error(f"Error manejando carga de CV: {str(e)}")
            return False

    async def _handle_view_cv(self, platform: str, user_id: str) -> bool:
        """Maneja la visualizaci√≥n del CV."""
        try:
            # Obtener CV del usuario
            cv = await self.service.get_cv(user_id)

            if not cv:
                message = "‚ùå No tienes un CV registrado."
                return await self.service.send_message(platform, user_id, message)

            # Enviar CV
            return await self.service.send_file(platform, user_id, cv)

        except Exception as e:
            self.logger.error(f"Error mostrando CV: {str(e)}")
            return False

    async def _handle_edit_cv(self, platform: str, user_id: str) -> bool:
        """Maneja la edici√≥n del CV."""
        try:
            # Obtener CV del usuario
            cv = await self.service.get_cv(user_id)

            if not cv:
                message = "‚ùå No tienes un CV registrado. ¬øDeseas crear uno?"
                buttons = [
                    {"title": "üìù Crear CV", "payload": "crear_cv"},
                    {"title": "‚ùå Cancelar", "payload": "menu"}
                ]
                return await self.service.send_options(platform, user_id, message, buttons)

            # Mostrar campos editables
            message = "‚úèÔ∏è *Editar CV*\n\nSelecciona el campo que deseas editar:\n\n"
            message += "1Ô∏è‚É£ Nombre del CV\n"
            message += "2Ô∏è‚É£ Descripci√≥n del CV\n"
            message += "3Ô∏è‚É£ Experiencia laboral\n"
            message += "4Ô∏è‚É£ Educaci√≥n\n"
            message += "5Ô∏è‚É£ Habilidades\n\n"
            message += "Escribe el n√∫mero del campo que deseas editar."

            # Actualizar estado del chat
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_edit_cv"
                await chat_state.asave()

            return await self.service.send_message(platform, user_id, message)

        except Exception as e:
            self.logger.error(f"Error iniciando edici√≥n de CV: {str(e)}")
            return False

    async def _handle_search_jobs(self, platform: str, user_id: str) -> bool:
        """Maneja la b√∫squeda de vacantes."""
        try:
            # Enviar mensaje solicitando t√©rmino de b√∫squeda
            message = "üîç *B√∫squeda de Vacantes*\n\nPor favor, escribe el t√©rmino que deseas buscar:"
            await self.service.send_message(platform, user_id, message)
            
            # Actualizar estado para esperar t√©rmino de b√∫squeda
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_job_search"
                await chat_state.asave()
            
            return True

        except Exception as e:
            self.logger.error(f"Error en b√∫squeda de vacantes: {str(e)}")
            return False

    async def _handle_recommended_jobs(self, platform: str, user_id: str) -> bool:
        """Maneja la visualizaci√≥n de vacantes recomendadas."""
        try:
            # Obtener vacantes recomendadas
            jobs = await self.service.get_recommended_jobs(user_id)

            if not jobs:
                message = "‚ùå No hay vacantes recomendadas disponibles."
                return await self.service.send_message(platform, user_id, message)

            # Construir mensaje con informaci√≥n de las vacantes
            message = "üìã *Vacantes Recomendadas*\n\n"
            for job in jobs:
                message += f"*T√≠tulo:* {job.title}\n"
                message += f"*Empresa:* {job.company}\n"
                message += f"*Ubicaci√≥n:* {job.location}\n"
                message += f"*Fecha de publicaci√≥n:* {job.date}\n\n"

            # Enviar mensaje
            return await self.service.send_message(platform, user_id, message)

        except Exception as e:
            self.logger.error(f"Error mostrando vacantes recomendadas: {str(e)}")
            return False

    async def _handle_my_applications(self, platform: str, user_id: str) -> bool:
        """Maneja la visualizaci√≥n de postulaciones."""
        try:
            # Obtener postulaciones del usuario
            applications = await self.service.get_applications(user_id)

            if not applications:
                message = "‚ùå No tienes postulaciones registradas."
                return await self.service.send_message(platform, user_id, message)

            # Construir mensaje con informaci√≥n de las postulaciones
            message = "üìã *Mis Postulaciones*\n\n"
            for application in applications:
                message += f"*T√≠tulo:* {application.job.title}\n"
                message += f"*Empresa:* {application.job.company}\n"
                message += f"*Ubicaci√≥n:* {application.job.location}\n"
                message += f"*Fecha de postulaci√≥n:* {application.date}\n\n"

            # Enviar mensaje
            return await self.service.send_message(platform, user_id, message)

        except Exception as e:
            self.logger.error(f"Error mostrando postulaciones: {str(e)}")
            return False

    async def _handle_schedule_interview(self, platform: str, user_id: str) -> bool:
        """Maneja la programaci√≥n de una entrevista."""
        try:
            # Enviar mensaje solicitando informaci√≥n de la entrevista
            message = "üìÖ *Programaci√≥n de Entrevista*\n\nPor favor, proporciona la siguiente informaci√≥n:"
            message += "\n1Ô∏è‚É£ Fecha de la entrevista"
            message += "\n2Ô∏è‚É£ Hora de la entrevista"
            message += "\n3Ô∏è‚É£ Lugar de la entrevista"
            message += "\n4Ô∏è‚É£ Nombre del entrevistador"
            message += "\n5Ô∏è‚É£ Detalles adicionales"
            message += "\n\nEscribe 'comenzar' para iniciar el proceso."

            # Actualizar estado del chat
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_schedule_interview"
                await chat_state.asave()

            return await self.service.send_message(platform, user_id, message)

        except Exception as e:
            self.logger.error(f"Error manejando programaci√≥n de entrevista: {str(e)}")
            return False

    async def _handle_view_interviews(self, platform: str, user_id: str) -> bool:
        """Maneja la visualizaci√≥n de entrevistas."""
        try:
            # Obtener entrevistas del usuario
            interviews = await self.service.get_interviews(user_id)

            if not interviews:
                message = "‚ùå No tienes entrevistas registradas."
                return await self.service.send_message(platform, user_id, message)

            # Construir mensaje con informaci√≥n de las entrevistas
            message = "üìÖ *Entrevistas*\n\n"
            for interview in interviews:
                message += f"*T√≠tulo:* {interview.title}\n"
                message += f"*Fecha:* {interview.date}\n"
                message += f"*Lugar:* {interview.location}\n"
                message += f"*Entrevistador:* {interview.interviewer}\n\n"

            # Enviar mensaje
            return await self.service.send_message(platform, user_id, message)

        except Exception as e:
            self.logger.error(f"Error mostrando entrevistas: {str(e)}")
            return False

    async def _handle_modify_interview(self, platform: str, user_id: str) -> bool:
        """Maneja la modificaci√≥n de una entrevista."""
        try:
            # Enviar mensaje solicitando informaci√≥n de la entrevista
            message = "üìÖ *Modificaci√≥n de Entrevista*\n\nPor favor, proporciona la siguiente informaci√≥n:"
            message += "\n1Ô∏è‚É£ Nueva fecha de la entrevista"
            message += "\n2Ô∏è‚É£ Nueva hora de la entrevista"
            message += "\n3Ô∏è‚É£ Nuevo lugar de la entrevista"
            message += "\n4Ô∏è‚É£ Nuevo entrevistador"
            message += "\n5Ô∏è‚É£ Detalles adicionales"
            message += "\n\nEscribe 'comenzar' para iniciar el proceso."

            # Actualizar estado del chat
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_modify_interview"
                await chat_state.asave()

            return await self.service.send_message(platform, user_id, message)

        except Exception as e:
            self.logger.error(f"Error manejando modificaci√≥n de entrevista: {str(e)}")
            return False

    async def _handle_net_to_gross(self, platform: str, user_id: str) -> bool:
        """Maneja la conversi√≥n de neto a bruto."""
        try:
            # Enviar mensaje solicitando informaci√≥n para la conversi√≥n
            message = "üí∞ *Conversi√≥n de Neto a Bruto*\n\nPor favor, proporciona la siguiente informaci√≥n:"
            await self.service.send_message(platform, user_id, message)
            
            # Actualizar estado para esperar respuesta
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_net_to_gross"
                await chat_state.asave()
            
            return True

        except Exception as e:
            self.logger.error(f"Error manejando conversi√≥n de neto a bruto: {str(e)}")
            return False

    async def _handle_gross_to_net(self, platform: str, user_id: str) -> bool:
        """Maneja la conversi√≥n de bruto a neto."""
        try:
            # Enviar mensaje solicitando informaci√≥n para la conversi√≥n
            message = "üí∞ *Conversi√≥n de Bruto a Neto*\n\nPor favor, proporciona la siguiente informaci√≥n:"
            await self.service.send_message(platform, user_id, message)
            
            # Actualizar estado para esperar respuesta
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_gross_to_net"
                await chat_state.asave()
            
            return True

        except Exception as e:
            self.logger.error(f"Error manejando conversi√≥n de bruto a neto: {str(e)}")
            return False

    async def _handle_chat_advisor(self, platform: str, user_id: str) -> bool:
        """Maneja la solicitud de chat con un asesor."""
        try:
            # Enviar mensaje solicitando informaci√≥n para el chat
            message = "üí¨ *Chat con Asesor*\n\nPor favor, escribe tu consulta:"
            await self.service.send_message(platform, user_id, message)
            
            # Actualizar estado para esperar respuesta
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_chat_advisor"
                await chat_state.asave()
            
            return True

        except Exception as e:
            self.logger.error(f"Error manejando chat con asesor: {str(e)}")
            return False

    async def _handle_schedule_appointment(self, platform: str, user_id: str) -> bool:
        """Maneja la programaci√≥n de una cita."""
        try:
            # Enviar mensaje solicitando informaci√≥n de la cita
            message = "üìÖ *Programaci√≥n de Cita*\n\nPor favor, proporciona la siguiente informaci√≥n:"
            message += "\n1Ô∏è‚É£ Fecha de la cita"
            message += "\n2Ô∏è‚É£ Hora de la cita"
            message += "\n3Ô∏è‚É£ Lugar de la cita"
            message += "\n4Ô∏è‚É£ Nombre del asesor"
            message += "\n5Ô∏è‚É£ Detalles adicionales"
            message += "\n\nEscribe 'comenzar' para iniciar el proceso."

            # Actualizar estado del chat
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_schedule_appointment"
                await chat_state.asave()

            return await self.service.send_message(platform, user_id, message)

        except Exception as e:
            self.logger.error(f"Error manejando programaci√≥n de cita: {str(e)}")
            return False

    async def _handle_view_mentors(self, platform: str, user_id: str) -> bool:
        """Maneja la visualizaci√≥n de mentores."""
        try:
            # Obtener mentores del usuario
            mentors = await self.service.get_mentors(user_id)

            if not mentors:
                message = "‚ùå No tienes mentores registrados."
                return await self.service.send_message(platform, user_id, message)

            # Construir mensaje con informaci√≥n de los mentores
            message = "üë®‚Äçüë©‚Äçüëß‚Äçüë¶ *Mentores*\n\n"
            for mentor in mentors:
                message += f"*Nombre:* {mentor.name}\n"
                message += f"*Especialidad:* {mentor.specialty}\n"
                message += f"*Contacto:* {mentor.contact}\n\n"

            # Enviar mensaje
            return await self.service.send_message(platform, user_id, message)

        except Exception as e:
            self.logger.error(f"Error mostrando mentores: {str(e)}")
            return False

    async def _handle_schedule_mentoring(self, platform: str, user_id: str) -> bool:
        """Maneja la programaci√≥n de una sesi√≥n de mentor√≠a."""
        try:
            # Enviar mensaje solicitando informaci√≥n de la sesi√≥n de mentor√≠a
            message = "üìÖ *Programaci√≥n de Sesi√≥n de Mentor√≠a*\n\nPor favor, proporciona la siguiente informaci√≥n:"
            message += "\n1Ô∏è‚É£ Fecha de la sesi√≥n"
            message += "\n2Ô∏è‚É£ Hora de la sesi√≥n"
            message += "\n3Ô∏è‚É£ Lugar de la sesi√≥n"
            message += "\n4Ô∏è‚É£ Nombre del mentor"
            message += "\n5Ô∏è‚É£ Detalles adicionales"
            message += "\n\nEscribe 'comenzar' para iniciar el proceso."

            # Actualizar estado del chat
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_schedule_mentoring"
                await chat_state.asave()

            return await self.service.send_message(platform, user_id, message)

        except Exception as e:
            self.logger.error(f"Error manejando programaci√≥n de sesi√≥n de mentor√≠a: {str(e)}")
            return False

    async def _handle_faq(self, platform: str, user_id: str) -> bool:
        """Maneja la solicitud de respuesta a preguntas frecuentes."""
        try:
            # Enviar mensaje solicitando pregunta
            message = "‚ùì *Pregunta Frecuente*\n\nPor favor, escribe tu pregunta:"
            await self.service.send_message(platform, user_id, message)
            
            # Actualizar estado para esperar respuesta
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_faq"
                await chat_state.asave()
            
            return True

        except Exception as e:
            self.logger.error(f"Error manejando solicitud de FAQ: {str(e)}")
            return False

    async def _handle_guides(self, platform: str, user_id: str) -> bool:
        """Maneja la solicitud de gu√≠as."""
        try:
            # Enviar mensaje solicitando gu√≠as
            message = "üìö *Gu√≠as*\n\nPor favor, selecciona el tema de inter√©s:"
            await self.service.send_message(platform, user_id, message)
            
            # Actualizar estado para esperar respuesta
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_guides"
                await chat_state.asave()
            
            return True

        except Exception as e:
            self.logger.error(f"Error manejando solicitud de gu√≠as: {str(e)}")
            return False

    async def _handle_tutorials(self, platform: str, user_id: str) -> bool:
        """Maneja la solicitud de tutoriales."""
        try:
            # Enviar mensaje solicitando tutoriales
            message = "üìö *Tutoriales*\n\nPor favor, selecciona el tema de inter√©s:"
            await self.service.send_message(platform, user_id, message)
            
            # Actualizar estado para esperar respuesta
            chat_state = await ChatState.objects.filter(
                user_id=user_id, business_unit=self.service.business_unit
            ).afirst()
            
            if chat_state:
                chat_state.state = "waiting_tutorials"
                await chat_state.asave()
            
            return True

        except Exception as e:
            self.logger.error(f"Error manejando solicitud de tutoriales: {str(e)}")
            return False

class AssessmentHandler(ABC):
    @abstractmethod
    def process(self, data: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """Procesa los datos del assessment"""
        pass

    @abstractmethod
    def get_questions(self, category: Optional[str] = None) -> List[Dict[str, Any]]:
        """Obtiene las preguntas del assessment"""
        pass

    @abstractmethod
    def analyze_answers(self, answers: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """Analiza las respuestas del assessment"""
        pass

class ProfessionalDNAHandler(AssessmentHandler):
    def __init__(self):
        self.analysis = ProfessionalDNAAnalysis()

    def process(self, data: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """Procesa los datos del ADN Profesional"""
        answers = data.get('answers', {})
        generation = context.get('generation', 'millennial')
        business_unit = context.get('business_unit', BusinessUnit.HUNTRED)
        
        results = self.analysis.analyze_answers(
            answers=answers,
            generation=generation,
            business_unit=business_unit
        )
        
        return {
            'results': results,
            'summary': self.analysis.get_analysis_summary(results)
        }

    def get_questions(self, category: Optional[str] = None) -> List[Dict[str, Any]]:
        """Obtiene las preguntas del ADN Profesional"""
        if category:
            return self.analysis.get_questions_by_category(QuestionCategory(category))
        return self.analysis.get_all_questions()

    def analyze_answers(self, answers: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """Analiza las respuestas del ADN Profesional"""
        generation = context.get('generation', 'millennial')
        business_unit = context.get('business_unit', BusinessUnit.HUNTRED)
        
        return self.analysis.analyze_answers(
            answers=answers,
            generation=generation,
            business_unit=business_unit
        )

class CulturalFitHandler(AssessmentHandler):
    def __init__(self):
        self.workflow = CulturalFitWorkflow()

    def process(self, data: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """Procesa los datos del Fit Cultural"""
        answers = data.get('answers', {})
        results = self.workflow.analyze_answers(answers)
        
        return {
            'results': results,
            'summary': self.workflow.get_summary(results)
        }

    def get_questions(self, category: Optional[str] = None) -> List[Dict[str, Any]]:
        """Obtiene las preguntas del Fit Cultural"""
        return self.workflow.get_questions(category)

    def analyze_answers(self, answers: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """Analiza las respuestas del Fit Cultural"""
        return self.workflow.analyze_answers(answers)

class TalentAnalysisHandler(AssessmentHandler):
    def __init__(self):
        self.workflow = TalentAnalysisWorkflow()

    def process(self, data: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """Procesa los datos del An√°lisis de Talento"""
        answers = data.get('answers', {})
        results = self.workflow.analyze_answers(answers)
        
        return {
            'results': results,
            'summary': self.workflow.get_summary(results)
        }

    def get_questions(self, category: Optional[str] = None) -> List[Dict[str, Any]]:
        """Obtiene las preguntas del An√°lisis de Talento"""
        return self.workflow.get_questions(category)

    def analyze_answers(self, answers: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """Analiza las respuestas del An√°lisis de Talento"""
        return self.workflow.analyze_answers(answers)

class PersonalityAssessmentHandler(AssessmentHandler):
    def __init__(self):
        self.assessment = PersonalityAssessment()

    def process(self, data: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """Procesa los datos de la Evaluaci√≥n de Personalidad"""
        answers = data.get('answers', {})
        results = self.assessment.analyze_answers(answers)
        
        return {
            'results': results,
            'summary': self.assessment.get_summary(results)
        }

    def get_questions(self, category: Optional[str] = None) -> List[Dict[str, Any]]:
        """Obtiene las preguntas de la Evaluaci√≥n de Personalidad"""
        return self.assessment.get_questions(category)

    def analyze_answers(self, answers: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, Any]:
        """Analiza las respuestas de la Evaluaci√≥n de Personalidad"""
        return self.assessment.analyze_answers(answers) 